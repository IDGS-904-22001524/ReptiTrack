<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/data/repository/TerrariumRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/data/repository/TerrariumRepositoryImpl.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.data.repository&#10;&#10;import com.waldoz_x.reptitrack.data.source.remote.HiveMqttClient&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import com.waldoz_x.reptitrack.domain.repository.TerrariumRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.firstOrNull&#10;import kotlinx.coroutines.flow.map&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton // Esta anotación es crucial para que Dagger Hilt provea una única instancia&#10;class TerrariumRepositoryImpl @Inject constructor( // Este constructor @Inject es crucial para la inyección de dependencias&#10;    private val hiveMqttClient: HiveMqttClient // Usar MQTT en vez de Firestore&#10;) : TerrariumRepository { // Asegúrate de que implementa la interfaz TerrariumRepository&#10;&#10;    /**&#10;     * Obtiene un flujo de todos los terrarios para un usuario específico desde la fuente de datos de Firebase.&#10;     * Mapea los objetos DTO (Data Transfer Objects) a objetos de dominio.&#10;     * @param userId El ID del usuario para el que se obtendrán los terrarios.&#10;     * @return Flow que emite una lista de objetos Terrarium.&#10;     */&#10;    override fun getAllTerrariums(userId: String): Flow&lt;List&lt;Terrarium&gt;&gt; {&#10;        // Ignora el userId recibido y usa el fijo&#10;        val fixedUserId = &quot;7oDVlQ5njlNcJ2Q32gf06Gd9Tq72&quot;&#10;        val fixedTerrariumId = &quot;esp02&quot;&#10;        return hiveMqttClient.terrariumSensorData.map { terrariumMap -&gt;&#10;            val userTerrariums = terrariumMap[fixedUserId] ?: emptyMap()&#10;            val sensorData = userTerrariums[fixedTerrariumId] ?: emptyMap()&#10;            listOf(&#10;                Terrarium(&#10;                    id = fixedTerrariumId,&#10;                    name = &quot;Terrario $fixedTerrariumId&quot;,&#10;                    dht22_1_temperature = sensorData[&quot;dht22_1_temperature&quot;]?.toFloatOrNull(),&#10;                    dht22_1_humidity = sensorData[&quot;dht22_1_humidity&quot;]?.toFloatOrNull(),&#10;                    dht22_2_temperature = sensorData[&quot;dht22_2_temperature&quot;]?.toFloatOrNull(),&#10;                    dht22_2_humidity = sensorData[&quot;dht22_2_humidity&quot;]?.toFloatOrNull(),&#10;                    dht22_3_temperature = sensorData[&quot;dht22_3_temperature&quot;]?.toFloatOrNull(),&#10;                    dht22_3_humidity = sensorData[&quot;dht22_3_humidity&quot;]?.toFloatOrNull(),&#10;                    dht22_4_temperature = sensorData[&quot;dht22_4_temperature&quot;]?.toFloatOrNull(),&#10;                    dht22_4_humidity = sensorData[&quot;dht22_4_humidity&quot;]?.toFloatOrNull(),&#10;                    ds18b20_1_temperature = sensorData[&quot;ds18b20_1_temperature&quot;]?.toFloatOrNull(),&#10;                    ds18b20_2_temperature = sensorData[&quot;ds18b20_2_temperature&quot;]?.toFloatOrNull(),&#10;                    ds18b20_3_temperature = sensorData[&quot;ds18b20_3_temperature&quot;]?.toFloatOrNull(),&#10;                    ds18b20_4_temperature = sensorData[&quot;ds18b20_4_temperature&quot;]?.toFloatOrNull(),&#10;                    ds18b20_5_temperature = sensorData[&quot;ds18b20_5_temperature&quot;]?.toFloatOrNull(),&#10;                    hc_sr04_1_distance = sensorData[&quot;hc_sr04_1_distance&quot;]?.toFloatOrNull(),&#10;                    pzem_1_power = sensorData[&quot;pzem_1_power&quot;]?.toFloatOrNull()&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene un terrario específico por su ID para un usuario desde la fuente de datos de Firebase.&#10;     * @param userId El ID del usuario actual.&#10;     * @param id El ID del terrario a obtener.&#10;     * @return El objeto Terrarium si se encuentra, o null si no.&#10;     */&#10;    override fun getTerrariumById(userId: String, id: String): Flow&lt;Terrarium?&gt; {&#10;        // Ignora el userId y id recibidos y usa los fijos&#10;        val fixedUserId = &quot;7oDVlQ5njlNcJ2Q32gf06Gd9Tq72&quot;&#10;        val fixedTerrariumId = &quot;esp02&quot;&#10;        return hiveMqttClient.terrariumSensorData.map { terrariumMap -&gt;&#10;            val userTerrariums = terrariumMap[fixedUserId] ?: emptyMap()&#10;            val sensorData = userTerrariums[fixedTerrariumId] ?: emptyMap()&#10;            Terrarium(&#10;                id = fixedTerrariumId,&#10;                name = &quot;Terrario $fixedTerrariumId&quot;,&#10;                dht22_1_temperature = sensorData[&quot;dht22_1_temperature&quot;]?.toFloatOrNull(),&#10;                dht22_1_humidity = sensorData[&quot;dht22_1_humidity&quot;]?.toFloatOrNull(),&#10;                dht22_2_temperature = sensorData[&quot;dht22_2_temperature&quot;]?.toFloatOrNull(),&#10;                dht22_2_humidity = sensorData[&quot;dht22_2_humidity&quot;]?.toFloatOrNull(),&#10;                dht22_3_temperature = sensorData[&quot;dht22_3_temperature&quot;]?.toFloatOrNull(),&#10;                dht22_3_humidity = sensorData[&quot;dht22_3_humidity&quot;]?.toFloatOrNull(),&#10;                dht22_4_temperature = sensorData[&quot;dht22_4_temperature&quot;]?.toFloatOrNull(),&#10;                dht22_4_humidity = sensorData[&quot;dht22_4_humidity&quot;]?.toFloatOrNull(),&#10;                ds18b20_1_temperature = sensorData[&quot;ds18b20_1_temperature&quot;]?.toFloatOrNull(),&#10;                ds18b20_2_temperature = sensorData[&quot;ds18b20_2_temperature&quot;]?.toFloatOrNull(),&#10;                ds18b20_3_temperature = sensorData[&quot;ds18b20_3_temperature&quot;]?.toFloatOrNull(),&#10;                ds18b20_4_temperature = sensorData[&quot;ds18b20_4_temperature&quot;]?.toFloatOrNull(),&#10;                ds18b20_5_temperature = sensorData[&quot;ds18b20_5_temperature&quot;]?.toFloatOrNull(),&#10;                hc_sr04_1_distance = sensorData[&quot;hc_sr04_1_distance&quot;]?.toFloatOrNull(),&#10;                pzem_1_power = sensorData[&quot;pzem_1_power&quot;]?.toFloatOrNull()&#10;            )&#10;        }&#10;    }&#10;&#10;    override suspend fun addTerrarium(userId: String, terrarium: Terrarium) {&#10;        throw NotImplementedError(&quot;Solo lectura por MQTT&quot;)&#10;    }&#10;&#10;    override suspend fun updateTerrarium(userId: String, terrarium: Terrarium) {&#10;        throw NotImplementedError(&quot;Solo lectura por MQTT&quot;)&#10;    }&#10;&#10;    override suspend fun deleteTerrarium(userId: String, id: String) {&#10;        throw NotImplementedError(&quot;Solo lectura por MQTT&quot;)&#10;    }&#10;&#10;    override suspend fun updateTerrariumActuatorState(userId: String, terrariumId: String, actuatorKey: String, newState: Boolean) {&#10;        // Publica el comando MQTT para cambiar el estado del actuador&#10;        val topic = &quot;terrarium/$terrariumId/actuators/$actuatorKey/set&quot;&#10;        val message = if (newState) &quot;ON&quot; else &quot;OFF&quot;&#10;        hiveMqttClient.publishMessage(topic, message)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.data.repository&#10;&#10;import com.waldoz_x.reptitrack.data.source.remote.HiveMqttClient&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import com.waldoz_x.reptitrack.domain.repository.TerrariumRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.firstOrNull&#10;import kotlinx.coroutines.flow.map&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton // Esta anotación es crucial para que Dagger Hilt provea una única instancia&#10;class TerrariumRepositoryImpl @Inject constructor( // Este constructor @Inject es crucial para la inyección de dependencias&#10;    private val hiveMqttClient: HiveMqttClient // Usar MQTT en vez de Firestore&#10;) : TerrariumRepository { // Asegúrate de que implementa la interfaz TerrariumRepository&#10;&#10;    /**&#10;     * Obtiene un flujo de todos los terrarios para un usuario específico desde la fuente de datos de Firebase.&#10;     * Mapea los objetos DTO (Data Transfer Objects) a objetos de dominio.&#10;     * @param userId El ID del usuario para el que se obtendrán los terrarios.&#10;     * @return Flow que emite una lista de objetos Terrarium.&#10;     */&#10;    override fun getAllTerrariums(userId: String): Flow&lt;List&lt;Terrarium&gt;&gt; {&#10;        val fixedTerrariumId = &quot;esp02&quot;&#10;        return hiveMqttClient.terrariumSensorData.map { terrariumMap -&gt;&#10;            val userTerrariums = terrariumMap[userId] ?: emptyMap()&#10;            val sensorData = userTerrariums[fixedTerrariumId] ?: emptyMap()&#10;            listOf(&#10;                Terrarium(&#10;                    id = fixedTerrariumId,&#10;                    name = &quot;Terrario $fixedTerrariumId&quot;,&#10;                    dht22_1_temperature = sensorData[&quot;dht22_1_temperature&quot;]?.toFloatOrNull(),&#10;                    dht22_1_humidity = sensorData[&quot;dht22_1_humidity&quot;]?.toFloatOrNull(),&#10;                    dht22_2_temperature = sensorData[&quot;dht22_2_temperature&quot;]?.toFloatOrNull(),&#10;                    dht22_2_humidity = sensorData[&quot;dht22_2_humidity&quot;]?.toFloatOrNull(),&#10;                    dht22_3_temperature = sensorData[&quot;dht22_3_temperature&quot;]?.toFloatOrNull(),&#10;                    dht22_3_humidity = sensorData[&quot;dht22_3_humidity&quot;]?.toFloatOrNull(),&#10;                    dht22_4_temperature = sensorData[&quot;dht22_4_temperature&quot;]?.toFloatOrNull(),&#10;                    dht22_4_humidity = sensorData[&quot;dht22_4_humidity&quot;]?.toFloatOrNull(),&#10;                    ds18b20_1_temperature = sensorData[&quot;ds18b20_1_temperature&quot;]?.toFloatOrNull(),&#10;                    ds18b20_2_temperature = sensorData[&quot;ds18b20_2_temperature&quot;]?.toFloatOrNull(),&#10;                    ds18b20_3_temperature = sensorData[&quot;ds18b20_3_temperature&quot;]?.toFloatOrNull(),&#10;                    ds18b20_4_temperature = sensorData[&quot;ds18b20_4_temperature&quot;]?.toFloatOrNull(),&#10;                    ds18b20_5_temperature = sensorData[&quot;ds18b20_5_temperature&quot;]?.toFloatOrNull(),&#10;                    hc_sr04_1_distance = sensorData[&quot;hc_sr04_1_distance&quot;]?.toFloatOrNull(),&#10;                    pzem_1_power = sensorData[&quot;pzem_1_power&quot;]?.toFloatOrNull()&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene un terrario específico por su ID para un usuario desde la fuente de datos de Firebase.&#10;     * @param userId El ID del usuario actual.&#10;     * @param id El ID del terrario a obtener.&#10;     * @return El objeto Terrarium si se encuentra, o null si no.&#10;     */&#10;    override fun getTerrariumById(userId: String, id: String): Flow&lt;Terrarium?&gt; {&#10;        val fixedTerrariumId = &quot;esp02&quot;&#10;        return hiveMqttClient.terrariumSensorData.map { terrariumMap -&gt;&#10;            val userTerrariums = terrariumMap[userId] ?: emptyMap()&#10;            val sensorData = userTerrariums[fixedTerrariumId] ?: emptyMap()&#10;            Terrarium(&#10;                id = fixedTerrariumId,&#10;                name = &quot;Terrario $fixedTerrariumId&quot;,&#10;                dht22_1_temperature = sensorData[&quot;dht22_1_temperature&quot;]?.toFloatOrNull(),&#10;                dht22_1_humidity = sensorData[&quot;dht22_1_humidity&quot;]?.toFloatOrNull(),&#10;                dht22_2_temperature = sensorData[&quot;dht22_2_temperature&quot;]?.toFloatOrNull(),&#10;                dht22_2_humidity = sensorData[&quot;dht22_2_humidity&quot;]?.toFloatOrNull(),&#10;                dht22_3_temperature = sensorData[&quot;dht22_3_temperature&quot;]?.toFloatOrNull(),&#10;                dht22_3_humidity = sensorData[&quot;dht22_3_humidity&quot;]?.toFloatOrNull(),&#10;                dht22_4_temperature = sensorData[&quot;dht22_4_temperature&quot;]?.toFloatOrNull(),&#10;                dht22_4_humidity = sensorData[&quot;dht22_4_humidity&quot;]?.toFloatOrNull(),&#10;                ds18b20_1_temperature = sensorData[&quot;ds18b20_1_temperature&quot;]?.toFloatOrNull(),&#10;                ds18b20_2_temperature = sensorData[&quot;ds18b20_2_temperature&quot;]?.toFloatOrNull(),&#10;                ds18b20_3_temperature = sensorData[&quot;ds18b20_3_temperature&quot;]?.toFloatOrNull(),&#10;                ds18b20_4_temperature = sensorData[&quot;ds18b20_4_temperature&quot;]?.toFloatOrNull(),&#10;                ds18b20_5_temperature = sensorData[&quot;ds18b20_5_temperature&quot;]?.toFloatOrNull(),&#10;                hc_sr04_1_distance = sensorData[&quot;hc_sr04_1_distance&quot;]?.toFloatOrNull(),&#10;                pzem_1_power = sensorData[&quot;pzem_1_power&quot;]?.toFloatOrNull()&#10;            )&#10;        }&#10;    }&#10;&#10;    override suspend fun addTerrarium(userId: String, terrarium: Terrarium) {&#10;        throw NotImplementedError(&quot;Solo lectura por MQTT&quot;)&#10;    }&#10;&#10;    override suspend fun updateTerrarium(userId: String, terrarium: Terrarium) {&#10;        throw NotImplementedError(&quot;Solo lectura por MQTT&quot;)&#10;    }&#10;&#10;    override suspend fun deleteTerrarium(userId: String, id: String) {&#10;        throw NotImplementedError(&quot;Solo lectura por MQTT&quot;)&#10;    }&#10;&#10;    override suspend fun updateTerrariumActuatorState(userId: String, terrariumId: String, actuatorKey: String, newState: Boolean) {&#10;        // Publica el comando MQTT para cambiar el estado del actuador&#10;        val topic = &quot;terrarium/$terrariumId/actuators/$actuatorKey/set&quot;&#10;        val message = if (newState) &quot;ON&quot; else &quot;OFF&quot;&#10;        hiveMqttClient.publishMessage(topic, message)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/data/source/remote/HiveMqttClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/data/source/remote/HiveMqttClient.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.data.source.remote&#10;&#10;import android.util.Log&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken&#10;import org.eclipse.paho.client.mqttv3.MqttCallbackExtended&#10;import org.eclipse.paho.client.mqttv3.MqttClient&#10;import org.eclipse.paho.client.mqttv3.MqttConnectOptions&#10;import org.eclipse.paho.client.mqttv3.MqttException&#10;import org.eclipse.paho.client.mqttv3.MqttMessage&#10;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence&#10;import org.json.JSONObject&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.resumeWithException&#10;&#10;// Esta clase manejará la conexión y comunicación con el broker MQTT&#10;@Singleton&#10;class HiveMqttClient @Inject constructor() {&#10;&#10;    private val TAG = &quot;HiveMqttClient&quot;&#10;&#10;    private val BROKER_URI = &quot;ssl://bda98a85f86a454891057738db2eb24c.s1.eu.hivemq.cloud:8883&quot;&#10;    internal val DEFAULT_USERNAME = &quot;dev_Android&quot;&#10;    internal val DEFAULT_PASSWORD = &quot;REXvALDO23&quot;&#10;&#10;    // Se inicializa como 'lateinit var' pero la inicialización real de MqttClient se moverá a connect()&#10;    // para evitar hacer trabajo pesado en el constructor o el bloque init.&#10;    private var mqttClient: MqttClient? = null // Hacerlo nullable para inicialización tardía&#10;&#10;    private val _isConnected = MutableStateFlow(false)&#10;    val isConnected: StateFlow&lt;Boolean&gt; = _isConnected&#10;&#10;    private val _receivedMessages = MutableStateFlow&lt;Pair&lt;String, String&gt;?&gt;(null)&#10;    val receivedMessages: StateFlow&lt;Pair&lt;String, String&gt;?&gt; = _receivedMessages&#10;&#10;    // --- NUEVO: Estado global de sensores por terrario ---&#10;    // userId -&gt; terrariumId -&gt; sensorKey -&gt; valor&#10;    private val _terrariumSensorData = MutableStateFlow&lt;Map&lt;String, Map&lt;String, Map&lt;String, String&gt;&gt;&gt;&gt;(emptyMap())&#10;    val terrariumSensorData: StateFlow&lt;Map&lt;String, Map&lt;String, Map&lt;String, String&gt;&gt;&gt;&gt; = _terrariumSensorData.asStateFlow()&#10;&#10;    // No hay bloque 'init' que haga trabajo pesado. La configuración se hace al conectar.&#10;&#10;    /**&#10;     * Inicializa el cliente MQTT si no ha sido inicializado y luego intenta conectar.&#10;     * Se puede llamar varias veces; solo inicializará el cliente una vez.&#10;     *&#10;     * @param username Nombre de usuario opcional para la conexión MQTT.&#10;     * @param password Contraseña opcional para la conexión MQTT.&#10;     */&#10;    suspend fun connect(username: String? = null, password: String? = null) {&#10;        if (_isConnected.value) {&#10;            Log.d(TAG, &quot;Cliente ya está conectado.&quot;)&#10;            return&#10;        }&#10;&#10;        // Inicializa el MqttClient solo si es nulo (primera vez o después de un reinicio)&#10;        if (mqttClient == null) {&#10;            try {&#10;                val clientId = UUID.randomUUID().toString()&#10;                mqttClient = MqttClient(BROKER_URI, clientId, MemoryPersistence())&#10;                setupMqttCallback() // Configura el callback una vez&#10;                Log.d(TAG, &quot;MqttClient inicializado.&quot;)&#10;            } catch (e: MqttException) {&#10;                Log.e(TAG, &quot;Error al inicializar MqttClient: ${e.message}&quot;, e)&#10;                _isConnected.value = false&#10;                return // No podemos continuar sin un cliente inicializado&#10;            }&#10;        }&#10;&#10;        try {&#10;            val options = MqttConnectOptions().apply {&#10;                isCleanSession = true&#10;                connectionTimeout = 30&#10;                keepAliveInterval = 30&#10;&#10;                val finalUsername = username ?: DEFAULT_USERNAME&#10;                val finalPassword = password ?: DEFAULT_PASSWORD&#10;&#10;                if (finalUsername.isNotBlank()) {&#10;                    this.userName = finalUsername&#10;                }&#10;                if (finalPassword.isNotBlank()) {&#10;                    this.password = finalPassword.toCharArray()&#10;                }&#10;            }&#10;&#10;            // Asegurarse de que el cliente no sea nulo antes de usarlo&#10;            val client = mqttClient ?: throw IllegalStateException(&quot;MqttClient no inicializado.&quot;)&#10;&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.connect(options)&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Conexión MQTT exitosa!&quot;)&#10;            _isConnected.value = true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al conectar al broker MQTT: ${e.message}&quot;, e)&#10;            _isConnected.value = false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Configura el MqttCallback para el cliente. Se llama solo una vez cuando el cliente es inicializado.&#10;     */&#10;    private fun setupMqttCallback() {&#10;        mqttClient?.setCallback(object : MqttCallbackExtended {&#10;            override fun connectComplete(reconnect: Boolean, serverURI: String) {&#10;                Log.d(TAG, &quot;Cliente MQTT conectado: $serverURI (reconnect: $reconnect)&quot;)&#10;                _isConnected.value = true&#10;            }&#10;&#10;            override fun connectionLost(cause: Throwable?) {&#10;                Log.e(TAG, &quot;Conexión MQTT perdida: ${cause?.message}&quot;, cause)&#10;                _isConnected.value = false&#10;            }&#10;&#10;            override fun messageArrived(topic: String, message: MqttMessage) {&#10;                val payload = String(message.payload)&#10;                Log.d(TAG, &quot;Mensaje recibido en $topic: $payload&quot;)&#10;                _receivedMessages.value = Pair(topic, payload)&#10;                // --- Procesar y actualizar el mapa de sensores ---&#10;                try {&#10;                    val parts = topic.split(&quot;/&quot;)&#10;                    if (parts.size &gt;= 6 &amp;&amp; parts[0] == &quot;reptritrack&quot;) {&#10;                        val userId = parts[1]&#10;                        val terrariumId = parts[2]&#10;                        val espId = parts[3]&#10;                        val tipo = parts[4]&#10;                        val sensorKeyRaw = parts[5] // ej: &quot;dht22_01&quot;, &quot;ds18b20_03&quot;&#10;                        // Normaliza el sensorKey: dht22_01 -&gt; dht22_1, ds18b20_03 -&gt; ds18b20_3&#10;                        val sensorKey = sensorKeyRaw.replace(&quot;_0&quot;, &quot;_&quot;)&#10;                        val json = JSONObject(payload)&#10;                        val sensorData = mutableMapOf&lt;String, String&gt;()&#10;                        json.keys().forEach { key -&gt;&#10;                            // Traduce las claves del JSON a las que espera la UI&#10;                            val mappedKey = when (key) {&#10;                                &quot;humedad&quot; -&gt; &quot;humidity&quot;&#10;                                &quot;temperatura&quot; -&gt; &quot;temperature&quot;&#10;                                else -&gt; key&#10;                            }&#10;                            sensorData[&quot;${sensorKey}_${mappedKey}&quot;] = json.get(key).toString()&#10;                        }&#10;                        _terrariumSensorData.update { oldMap -&gt;&#10;                            val userMap = oldMap[userId] ?: emptyMap()&#10;                            val terrariumMap = userMap[terrariumId]?.toMutableMap() ?: mutableMapOf()&#10;                            terrariumMap.putAll(sensorData)&#10;                            val newUserMap = userMap.toMutableMap().apply { put(terrariumId, terrariumMap) }&#10;                            oldMap.toMutableMap().apply { put(userId, newUserMap) }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error procesando mensaje MQTT: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            override fun deliveryComplete(token: IMqttDeliveryToken) {&#10;                Log.d(TAG, &quot;Entrega de mensaje completa: ${token.messageId}&quot;)&#10;            }&#10;        })&#10;    }&#10;&#10;    suspend fun disconnect() {&#10;        if (!_isConnected.value || mqttClient == null) {&#10;            Log.d(TAG, &quot;Cliente ya está desconectado o no inicializado.&quot;)&#10;            return&#10;        }&#10;        try {&#10;            // Asegurarse de que el cliente no sea nulo antes de usarlo&#10;            val client = mqttClient ?: return&#10;&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.disconnect()&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Desconexión MQTT exitosa!&quot;)&#10;            _isConnected.value = false&#10;            mqttClient = null // Libera el cliente para permitir una nueva inicialización si es necesario&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al desconectar del broker MQTT: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun subscribeToTopic(topic: String, qos: Int = 1) {&#10;        if (!_isConnected.value || mqttClient == null) {&#10;            Log.e(TAG, &quot;No se puede suscribir: Cliente no conectado o no inicializado.&quot;)&#10;            return&#10;        }&#10;        try {&#10;            val client = mqttClient ?: return&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.subscribe(topic, qos)&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Suscrito exitosamente al tópico: $topic, QoS: $qos&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Excepción al suscribirse al tópico $topic: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun unsubscribeFromTopic(topic: String) {&#10;        if (!_isConnected.value || mqttClient == null) {&#10;            Log.e(TAG, &quot;No se puede anular la suscripción: Cliente no conectado o no inicializado.&quot;)&#10;            return&#10;        }&#10;        try {&#10;            val client = mqttClient ?: return&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.unsubscribe(topic)&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Anulada la suscripción al tópico: $topic&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al anular la suscripción al tópico $topic: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun publishMessage(topic: String, message: String, qos: Int = 1, retained: Boolean = false) {&#10;        if (!_isConnected.value || mqttClient == null) {&#10;            Log.e(TAG, &quot;No se puede publicar: Cliente no conectado o no inicializado.&quot;)&#10;            return&#10;        }&#10;        try {&#10;            val mqttMessage = MqttMessage(message.toByteArray()).apply {&#10;                this.qos = qos&#10;                this.isRetained = retained&#10;            }&#10;            val client = mqttClient ?: return&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.publish(topic, mqttMessage)&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Mensaje publicado en $topic: $message&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al publicar mensaje en $topic: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.data.source.remote&#10;&#10;import android.util.Log&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken&#10;import org.eclipse.paho.client.mqttv3.MqttCallbackExtended&#10;import org.eclipse.paho.client.mqttv3.MqttClient&#10;import org.eclipse.paho.client.mqttv3.MqttConnectOptions&#10;import org.eclipse.paho.client.mqttv3.MqttException&#10;import org.eclipse.paho.client.mqttv3.MqttMessage&#10;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence&#10;import org.json.JSONObject&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.resumeWithException&#10;&#10;// Esta clase manejará la conexión y comunicación con el broker MQTT&#10;@Singleton&#10;class HiveMqttClient @Inject constructor() {&#10;&#10;    private val TAG = &quot;HiveMqttClient&quot;&#10;&#10;    private val BROKER_URI = &quot;ssl://bda98a85f86a454891057738db2eb24c.s1.eu.hivemq.cloud:8883&quot;&#10;    internal val DEFAULT_USERNAME = &quot;dev_Android&quot;&#10;    internal val DEFAULT_PASSWORD = &quot;REXvALDO23&quot;&#10;&#10;    // Se inicializa como 'lateinit var' pero la inicialización real de MqttClient se moverá a connect()&#10;    // para evitar hacer trabajo pesado en el constructor o el bloque init.&#10;    private var mqttClient: MqttClient? = null // Hacerlo nullable para inicialización tardía&#10;&#10;    private val _isConnected = MutableStateFlow(false)&#10;    val isConnected: StateFlow&lt;Boolean&gt; = _isConnected&#10;&#10;    private val _receivedMessages = MutableStateFlow&lt;Pair&lt;String, String&gt;?&gt;(null)&#10;    val receivedMessages: StateFlow&lt;Pair&lt;String, String&gt;?&gt; = _receivedMessages&#10;&#10;    // --- NUEVO: Estado global de sensores por terrario ---&#10;    // userId -&gt; terrariumId -&gt; sensorKey -&gt; valor&#10;    private val _terrariumSensorData = MutableStateFlow&lt;Map&lt;String, Map&lt;String, Map&lt;String, String&gt;&gt;&gt;&gt;(emptyMap())&#10;    val terrariumSensorData: StateFlow&lt;Map&lt;String, Map&lt;String, Map&lt;String, String&gt;&gt;&gt;&gt; = _terrariumSensorData.asStateFlow()&#10;&#10;    // No hay bloque 'init' que haga trabajo pesado. La configuración se hace al conectar.&#10;&#10;    /**&#10;     * Inicializa el cliente MQTT si no ha sido inicializado y luego intenta conectar.&#10;     * Se puede llamar varias veces; solo inicializará el cliente una vez.&#10;     *&#10;     * @param username Nombre de usuario opcional para la conexión MQTT.&#10;     * @param password Contraseña opcional para la conexión MQTT.&#10;     */&#10;    suspend fun connect(username: String? = null, password: String? = null) {&#10;        if (_isConnected.value) {&#10;            Log.d(TAG, &quot;Cliente ya está conectado.&quot;)&#10;            return&#10;        }&#10;&#10;        // Inicializa el MqttClient solo si es nulo (primera vez o después de un reinicio)&#10;        if (mqttClient == null) {&#10;            try {&#10;                val clientId = UUID.randomUUID().toString()&#10;                mqttClient = MqttClient(BROKER_URI, clientId, MemoryPersistence())&#10;                setupMqttCallback() // Configura el callback una vez&#10;                Log.d(TAG, &quot;MqttClient inicializado.&quot;)&#10;            } catch (e: MqttException) {&#10;                Log.e(TAG, &quot;Error al inicializar MqttClient: ${e.message}&quot;, e)&#10;                _isConnected.value = false&#10;                return // No podemos continuar sin un cliente inicializado&#10;            }&#10;        }&#10;&#10;        try {&#10;            val options = MqttConnectOptions().apply {&#10;                isCleanSession = true&#10;                connectionTimeout = 30&#10;                keepAliveInterval = 30&#10;&#10;                val finalUsername = username ?: DEFAULT_USERNAME&#10;                val finalPassword = password ?: DEFAULT_PASSWORD&#10;&#10;                if (finalUsername.isNotBlank()) {&#10;                    this.userName = finalUsername&#10;                }&#10;                if (finalPassword.isNotBlank()) {&#10;                    this.password = finalPassword.toCharArray()&#10;                }&#10;            }&#10;&#10;            // Asegurarse de que el cliente no sea nulo antes de usarlo&#10;            val client = mqttClient ?: throw IllegalStateException(&quot;MqttClient no inicializado.&quot;)&#10;&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.connect(options)&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Conexión MQTT exitosa!&quot;)&#10;            _isConnected.value = true&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al conectar al broker MQTT: ${e.message}&quot;, e)&#10;            _isConnected.value = false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Configura el MqttCallback para el cliente. Se llama solo una vez cuando el cliente es inicializado.&#10;     */&#10;    private fun setupMqttCallback() {&#10;        mqttClient?.setCallback(object : MqttCallbackExtended {&#10;            override fun connectComplete(reconnect: Boolean, serverURI: String) {&#10;                Log.d(TAG, &quot;Cliente MQTT conectado: $serverURI (reconnect: $reconnect)&quot;)&#10;                _isConnected.value = true&#10;            }&#10;&#10;            override fun connectionLost(cause: Throwable?) {&#10;                Log.e(TAG, &quot;Conexión MQTT perdida: ${cause?.message}&quot;, cause)&#10;                _isConnected.value = false&#10;            }&#10;&#10;            override fun messageArrived(topic: String, message: MqttMessage) {&#10;                val payload = String(message.payload)&#10;                Log.d(TAG, &quot;Mensaje recibido en $topic: $payload&quot;)&#10;                _receivedMessages.value = Pair(topic, payload)&#10;                // --- Procesar y actualizar el mapa de sensores ---&#10;                try {&#10;                    val parts = topic.split(&quot;/&quot;)&#10;                    if (parts.size &gt;= 6 &amp;&amp; parts[0] == &quot;reptritrack&quot;) {&#10;                        val userId = parts[1]&#10;                        val terrariumId = parts[2]&#10;                        val espId = parts[3]&#10;                        val tipo = parts[4]&#10;                        val sensorKeyRaw = parts[5] // ej: &quot;dht22_01&quot;, &quot;ds18b20_03&quot;&#10;                        // Normaliza el sensorKey: dht22_01 -&gt; dht22_1, ds18b20_03 -&gt; ds18b20_3&#10;                        val sensorKey = sensorKeyRaw.replace(&quot;_0&quot;, &quot;_&quot;)&#10;                        val json = JSONObject(payload)&#10;                        val sensorData = mutableMapOf&lt;String, String&gt;()&#10;                        json.keys().forEach { key -&gt;&#10;                            // Traduce las claves del JSON a las que espera la UI&#10;                            val mappedKey = when (key) {&#10;                                &quot;humedad&quot; -&gt; &quot;humidity&quot;&#10;                                &quot;temperatura&quot; -&gt; &quot;temperature&quot;&#10;                                else -&gt; key&#10;                            }&#10;                            sensorData[&quot;${sensorKey}_${mappedKey}&quot;] = json.get(key).toString()&#10;                        }&#10;                        _terrariumSensorData.update { oldMap -&gt;&#10;                            val userMap = oldMap[userId] ?: emptyMap()&#10;                            val terrariumMap = userMap[terrariumId]?.toMutableMap() ?: mutableMapOf()&#10;                            terrariumMap.putAll(sensorData)&#10;                            val newUserMap = userMap.toMutableMap().apply { put(terrariumId, terrariumMap) }&#10;                            oldMap.toMutableMap().apply { put(userId, newUserMap) }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error procesando mensaje MQTT: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;&#10;            override fun deliveryComplete(token: IMqttDeliveryToken) {&#10;                Log.d(TAG, &quot;Entrega de mensaje completa: ${token.messageId}&quot;)&#10;            }&#10;        })&#10;    }&#10;&#10;    suspend fun disconnect() {&#10;        if (!_isConnected.value || mqttClient == null) {&#10;            Log.d(TAG, &quot;Cliente ya está desconectado o no inicializado.&quot;)&#10;            return&#10;        }&#10;        try {&#10;            // Asegurarse de que el cliente no sea nulo antes de usarlo&#10;            val client = mqttClient ?: return&#10;&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.disconnect()&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Desconexión MQTT exitosa!&quot;)&#10;            _isConnected.value = false&#10;            mqttClient = null // Libera el cliente para permitir una nueva inicialización si es necesario&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al desconectar del broker MQTT: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun subscribeToTopic(topic: String, qos: Int = 1) {&#10;        if (!_isConnected.value || mqttClient == null) {&#10;            Log.e(TAG, &quot;No se puede suscribir: Cliente no conectado o no inicializado.&quot;)&#10;            return&#10;        }&#10;        try {&#10;            val client = mqttClient ?: return&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.subscribe(topic, qos)&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Suscrito exitosamente al tópico: $topic, QoS: $qos&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Excepción al suscribirse al tópico $topic: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun unsubscribeFromTopic(topic: String) {&#10;        if (!_isConnected.value || mqttClient == null) {&#10;            Log.e(TAG, &quot;No se puede anular la suscripción: Cliente no conectado o no inicializado.&quot;)&#10;            return&#10;        }&#10;        try {&#10;            val client = mqttClient ?: return&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.unsubscribe(topic)&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Anulada la suscripción al tópico: $topic&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al anular la suscripción al tópico $topic: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun publishMessage(topic: String, message: String, qos: Int = 1, retained: Boolean = false) {&#10;        if (!_isConnected.value || mqttClient == null) {&#10;            Log.e(TAG, &quot;No se puede publicar: Cliente no conectado o no inicializado.&quot;)&#10;            return&#10;        }&#10;        try {&#10;            val mqttMessage = MqttMessage(message.toByteArray()).apply {&#10;                this.qos = qos&#10;                this.isRetained = retained&#10;            }&#10;            val client = mqttClient ?: return&#10;            suspendCancellableCoroutine&lt;Unit&gt; { continuation -&gt;&#10;                try {&#10;                    client.publish(topic, mqttMessage)&#10;                    continuation.resume(Unit)&#10;                } catch (e: MqttException) {&#10;                    continuation.resumeWithException(e)&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Mensaje publicado en $topic: $message&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al publicar mensaje en $topic: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun subscribeToSensorTopics(userId: String, terrariumId: String = &quot;esp02&quot;) {&#10;        val topic = &quot;reptritrack/$userId/$terrariumId/sensores/#&quot;&#10;        subscribeToTopic(topic, qos = 1)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/data/source/remote/TerrariumFirebaseDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/data/source/remote/TerrariumFirebaseDataSource.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.data.source.remote&#10;&#10;import android.util.Log&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FirebaseFirestoreException&#10;import com.google.firebase.firestore.QuerySnapshot&#10;import com.waldoz_x.reptitrack.data.model.TerrariumDto&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;import kotlinx.coroutines.tasks.await&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class TerrariumFirebaseDataSource @Inject constructor(&#10;    private val firestore: FirebaseFirestore&#10;) {&#10;    private val TAG = &quot;TerrariumFirebaseDS&quot;&#10;&#10;    // Función auxiliar para obtener la colección de terrarios de un usuario específico&#10;    private fun getUserTerrariumsCollection(userId: String) =&#10;        firestore.collection(&quot;usuarios&quot;).document(userId).collection(&quot;terrarios&quot;)&#10;&#10;    /**&#10;     * Obtiene un flujo de todos los terrarios DTO para un usuario específico desde Firestore en tiempo real.&#10;     * @param userId El ID del usuario actual.&#10;     * @return Flow que emite una lista de objetos TerrariumDto.&#10;     */&#10;    fun getAllTerrariums(userId: String): Flow&lt;List&lt;TerrariumDto&gt;&gt; = callbackFlow {&#10;        val subscription = getUserTerrariumsCollection(userId) // Usa la colección específica del usuario&#10;            .addSnapshotListener { snapshot, e -&gt;&#10;                if (e != null) {&#10;                    Log.e(TAG, &quot;Error al escuchar terrarios para el usuario $userId: ${e.message}&quot;, e)&#10;                    close(e)&#10;                    return@addSnapshotListener&#10;                }&#10;&#10;                if (snapshot != null &amp;&amp; !snapshot.isEmpty) {&#10;                    val terrariums = snapshot.documents.mapNotNull { doc -&gt;&#10;                        try {&#10;                            doc.toObject(TerrariumDto::class.java)&#10;                        } catch (ex: Exception) {&#10;                            Log.e(TAG, &quot;Error mapeando documento ${doc.id} a TerrariumDto para el usuario $userId: ${ex.message}&quot;, ex)&#10;                            null&#10;                        }&#10;                    }&#10;                    trySend(terrariums).isSuccess&#10;                } else {&#10;                    trySend(emptyList()).isSuccess&#10;                }&#10;            }&#10;        awaitClose { subscription.remove() }&#10;    }&#10;&#10;    /**&#10;     * Obtiene un flujo de un terrario DTO específico por su ID para un usuario desde Firestore en tiempo real.&#10;     * @param userId El ID del usuario actual.&#10;     * @param terrariumId El ID del terrario a obtener.&#10;     * @return Flow que emite el objeto TerrariumDto si se encuentra, o null si no.&#10;     */&#10;    fun getTerrariumById(userId: String, terrariumId: String): Flow&lt;TerrariumDto?&gt; = callbackFlow {&#10;        if (userId.isBlank() || terrariumId.isBlank()) {&#10;            Log.e(TAG, &quot;getTerrariumById: userId o terrariumId vacío. userId='$userId', terrariumId='$terrariumId'&quot;)&#10;            trySend(null).isSuccess // Opcional: puedes enviar null para que la UI muestre &quot;N/A&quot;&#10;            close(IllegalArgumentException(&quot;userId y terrariumId no pueden estar vacíos&quot;))&#10;            return@callbackFlow&#10;        }&#10;&#10;        val docRef = getUserTerrariumsCollection(userId).document(terrariumId)&#10;        val subscription = docRef.addSnapshotListener { snapshot, e -&gt;&#10;            if (e != null) {&#10;                Log.e(TAG, &quot;Error al escuchar terrario por ID ($terrariumId) para el usuario $userId: ${e.message}&quot;, e)&#10;                close(e)&#10;                return@addSnapshotListener&#10;            }&#10;&#10;            if (snapshot != null &amp;&amp; snapshot.exists()) {&#10;                val terrariumDto = snapshot.toObject(TerrariumDto::class.java)&#10;                trySend(terrariumDto).isSuccess&#10;            } else {&#10;                trySend(null).isSuccess&#10;            }&#10;        }&#10;        awaitClose { subscription.remove() }&#10;    }&#10;&#10;    /**&#10;     * Añade un nuevo terrario DTO para un usuario específico a Firestore.&#10;     * @param userId El ID del usuario actual.&#10;     * @param terrarium El objeto TerrariumDto a añadir.&#10;     */&#10;    suspend fun addTerrarium(userId: String, terrarium: TerrariumDto) {&#10;        try {&#10;            getUserTerrariumsCollection(userId).document(terrarium.id).set(terrarium).await() // Usa la colección específica del usuario&#10;            Log.d(TAG, &quot;Terrario añadido/actualizado para el usuario $userId: ${terrarium.id}&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al añadir terrario para el usuario $userId: ${e.message}&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza un terrario DTO existente para un usuario específico en Firestore.&#10;     * Simplemente llama a addTerrarium ya que Firestore.set() actualiza o crea.&#10;     * @param userId El ID del usuario actual.&#10;     * @param terrarium El objeto TerrariumDto con los datos actualizados.&#10;     */&#10;    suspend fun updateTerrarium(userId: String, terrarium: TerrariumDto) {&#10;        addTerrarium(userId, terrarium) // set() se encarga de actualizar si el documento ya existe&#10;    }&#10;&#10;    /**&#10;     * Elimina un terrario por su ID para un usuario específico de Firestore.&#10;     * @param userId El ID del usuario actual.&#10;     * @param terrariumId El ID del terrario a eliminar.&#10;     */&#10;    suspend fun deleteTerrarium(userId: String, terrariumId: String) {&#10;        try {&#10;            getUserTerrariumsCollection(userId).document(terrariumId).delete().await() // Usa la colección específica del usuario&#10;            Log.d(TAG, &quot;Terrario eliminado para el usuario $userId: $terrariumId&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al eliminar terrario ($terrariumId) para el usuario $userId: ${e.message}&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.data.source.remote&#10;&#10;import android.util.Log&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.FirebaseFirestoreException&#10;import com.google.firebase.firestore.QuerySnapshot&#10;import com.waldoz_x.reptitrack.data.model.TerrariumDto&#10;import kotlinx.coroutines.channels.awaitClose&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.callbackFlow&#10;import kotlinx.coroutines.tasks.await&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class TerrariumFirebaseDataSource @Inject constructor(&#10;    private val firestore: FirebaseFirestore&#10;) {&#10;    private val TAG = &quot;TerrariumFirebaseDS&quot;&#10;&#10;    // Función auxiliar para obtener la colección de terrarios de un usuario específico&#10;    private fun getUserTerrariumsCollection(userId: String) =&#10;        firestore.collection(&quot;usuarios&quot;).document(userId).collection(&quot;terrarios&quot;)&#10;&#10;    /**&#10;     * Obtiene un flujo de todos los terrarios DTO para un usuario específico desde Firestore en tiempo real.&#10;     * @param userId El ID del usuario actual.&#10;     * @return Flow que emite una lista de objetos TerrariumDto.&#10;     */&#10;    fun getAllTerrariums(userId: String): Flow&lt;List&lt;TerrariumDto&gt;&gt; = callbackFlow {&#10;        val subscription = getUserTerrariumsCollection(userId)&#10;            .addSnapshotListener { snapshot, e -&gt;&#10;                if (e != null) {&#10;                    Log.e(TAG, &quot;Error al escuchar terrarios para el usuario $userId: ${e.message}&quot;, e)&#10;                    close(e)&#10;                    return@addSnapshotListener&#10;                }&#10;&#10;                // Cambia la lógica para que siempre emita una lista (vacía o con datos)&#10;                val terrariums = if (snapshot != null &amp;&amp; !snapshot.isEmpty) {&#10;                    snapshot.documents.mapNotNull { doc -&gt;&#10;                        try {&#10;                            doc.toObject(TerrariumDto::class.java)&#10;                        } catch (ex: Exception) {&#10;                            Log.e(TAG, &quot;Error mapeando documento ${doc.id} a TerrariumDto para el usuario $userId: ${ex.message}&quot;, ex)&#10;                            null&#10;                        }&#10;                    }&#10;                } else {&#10;                    emptyList()&#10;                }&#10;                trySend(terrariums).isSuccess&#10;            }&#10;        awaitClose { subscription.remove() }&#10;    }&#10;&#10;    /**&#10;     * Obtiene un flujo de un terrario DTO específico por su ID para un usuario desde Firestore en tiempo real.&#10;     * @param userId El ID del usuario actual.&#10;     * @param terrariumId El ID del terrario a obtener.&#10;     * @return Flow que emite el objeto TerrariumDto si se encuentra, o null si no.&#10;     */&#10;    fun getTerrariumById(userId: String, terrariumId: String): Flow&lt;TerrariumDto?&gt; = callbackFlow {&#10;        // La validación ya existe:&#10;        if (userId.isBlank() || terrariumId.isBlank()) {&#10;            Log.e(TAG, &quot;getTerrariumById: userId o terrariumId vacío. userId='$userId', terrariumId='$terrariumId'&quot;)&#10;            trySend(null).isSuccess&#10;            close(IllegalArgumentException(&quot;userId y terrariumId no pueden estar vacíos&quot;))&#10;            return@callbackFlow&#10;        }&#10;&#10;        val docRef = getUserTerrariumsCollection(userId).document(terrariumId)&#10;        val subscription = docRef.addSnapshotListener { snapshot, e -&gt;&#10;            if (e != null) {&#10;                Log.e(TAG, &quot;Error al escuchar terrario por ID ($terrariumId) para el usuario $userId: ${e.message}&quot;, e)&#10;                close(e)&#10;                return@addSnapshotListener&#10;            }&#10;&#10;            if (snapshot != null &amp;&amp; snapshot.exists()) {&#10;                val terrariumDto = snapshot.toObject(TerrariumDto::class.java)&#10;                trySend(terrariumDto).isSuccess&#10;            } else {&#10;                trySend(null).isSuccess&#10;            }&#10;        }&#10;        awaitClose { subscription.remove() }&#10;    }&#10;&#10;    /**&#10;     * Añade un nuevo terrario DTO para un usuario específico a Firestore.&#10;     * @param userId El ID del usuario actual.&#10;     * @param terrarium El objeto TerrariumDto a añadir.&#10;     */&#10;    suspend fun addTerrarium(userId: String, terrarium: TerrariumDto) {&#10;        try {&#10;            getUserTerrariumsCollection(userId).document(terrarium.id).set(terrarium).await() // Usa la colección específica del usuario&#10;            Log.d(TAG, &quot;Terrario añadido/actualizado para el usuario $userId: ${terrarium.id}&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al añadir terrario para el usuario $userId: ${e.message}&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza un terrario DTO existente para un usuario específico en Firestore.&#10;     * Simplemente llama a addTerrarium ya que Firestore.set() actualiza o crea.&#10;     * @param userId El ID del usuario actual.&#10;     * @param terrarium El objeto TerrariumDto con los datos actualizados.&#10;     */&#10;    suspend fun updateTerrarium(userId: String, terrarium: TerrariumDto) {&#10;        addTerrarium(userId, terrarium) // set() se encarga de actualizar si el documento ya existe&#10;    }&#10;&#10;    /**&#10;     * Elimina un terrario por su ID para un usuario específico de Firestore.&#10;     * @param userId El ID del usuario actual.&#10;     * @param terrariumId El ID del terrario a eliminar.&#10;     */&#10;    suspend fun deleteTerrarium(userId: String, terrariumId: String) {&#10;        try {&#10;            getUserTerrariumsCollection(userId).document(terrariumId).delete().await() // Usa la colección específica del usuario&#10;            Log.d(TAG, &quot;Terrario eliminado para el usuario $userId: $terrariumId&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error al eliminar terrario ($terrariumId) para el usuario $userId: ${e.message}&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/navigation/AppNavHost.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/navigation/AppNavHost.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.navigation&#10;&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.navArgument&#10;import com.waldoz_x.reptitrack.presentation.wifi.WiFiScanScreen&#10;import com.waldoz_x.reptitrack.ui.screens.home.HomeRoute&#10;import com.waldoz_x.reptitrack.ui.screens.settings.SettingsScreen&#10;import com.waldoz_x.reptitrack.ui.screens.timezone.TimeZoneSelectionScreen&#10;import com.waldoz_x.reptitrack.ui.screens.countryregion.CountryRegionSelectionScreen&#10;import com.waldoz_x.reptitrack.ui.screens.mqtt.MqttSettingsScreen&#10;import com.waldoz_x.reptitrack.ui.screens.terrariumdetail.TerrariumDetailScreen&#10;import com.waldoz_x.reptitrack.ui.screens.provisioning.*&#10;&#10;&#10;// Define las rutas de navegación como constantes para evitar errores de tipeo&#10;object Destinations {&#10;    const val HOME_ROUTE = &quot;home_route&quot;&#10;    const val SETTINGS_ROUTE = &quot;settings_route&quot;&#10;    const val TIME_ZONE_SELECTION_ROUTE = &quot;time_zone_selection_route&quot;&#10;    const val COUNTRY_REGION_SELECTION_ROUTE = &quot;country_region_selection_route&quot;&#10;    const val MQTT_SETTINGS_ROUTE = &quot;mqtt_settings_route&quot;&#10;&#10;    const val TERRARIUM_ID_ARG = &quot;terrariumId&quot;&#10;    const val TERRARIUM_DETAIL_ROUTE = &quot;terrarium_detail_route/{$TERRARIUM_ID_ARG}&quot;&#10;&#10;    const val TERRARIUM_SETUP_CREDENTIALS = &quot;terrarium_setup_credentials&quot;&#10;    const val BLUETOOTH_SCAN_ROUTE = &quot;bluetooth_scan_route&quot;&#10;    const val TERRARIUM_SETUP_WIFI = &quot;terrarium_setup_wifi&quot;&#10;    const val TERRARIUM_SETUP_SENDING = &quot;terrarium_setup_sending&quot;&#10;    const val TERRARIUM_SETUP_CHECKPOINT = &quot;terrarium_setup_checkpoint&quot;&#10;    const val TERRARIUM_SETUP_COMPLETED = &quot;terrarium_setup_completed&quot;&#10;}&#10;&#10;@Composable&#10;fun AppNavHost(&#10;    navController: NavHostController,&#10;    modifier: Modifier = Modifier,&#10;    startDestination: String = Destinations.HOME_ROUTE&#10;) {&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = startDestination,&#10;        modifier = modifier&#10;    ) {&#10;        composable(Destinations.HOME_ROUTE) {&#10;            HomeRoute(&#10;                navigateToTerrariumDetail = { terrariumId -&gt;&#10;                    navController.navigate(&#10;                        Destinations.TERRARIUM_DETAIL_ROUTE.replace(&#10;                            &quot;{${Destinations.TERRARIUM_ID_ARG}}&quot;, terrariumId&#10;                        )&#10;                    )&#10;                },&#10;                navigateToSettings = { navController.navigate(Destinations.SETTINGS_ROUTE) },&#10;                onAddTerrarium = { navController.navigate(Destinations.TERRARIUM_SETUP_CREDENTIALS) }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.SETTINGS_ROUTE) {&#10;            SettingsScreen(&#10;                onBackClick = { navController.popBackStack() },&#10;                navigateToTimeZoneSelection = { navController.navigate(Destinations.TIME_ZONE_SELECTION_ROUTE) },&#10;                navigateToCountryRegionSelection = { navController.navigate(Destinations.COUNTRY_REGION_SELECTION_ROUTE) },&#10;                navigateToMqttSettings = { navController.navigate(Destinations.MQTT_SETTINGS_ROUTE) },&#10;                navigateToTerrariumDetailPlaceholder = {&#10;                    navController.navigate(&#10;                        Destinations.TERRARIUM_DETAIL_ROUTE.replace(&#10;                            &quot;{${Destinations.TERRARIUM_ID_ARG}}&quot;, &quot;placeholder_terrarium_id&quot;&#10;                        )&#10;                    )&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TIME_ZONE_SELECTION_ROUTE) {&#10;            TimeZoneSelectionScreen(onBackClick = { navController.popBackStack() })&#10;        }&#10;&#10;        composable(Destinations.COUNTRY_REGION_SELECTION_ROUTE) {&#10;            CountryRegionSelectionScreen(onBackClick = { navController.popBackStack() })&#10;        }&#10;&#10;        composable(Destinations.MQTT_SETTINGS_ROUTE) {&#10;            MqttSettingsScreen(onBackClick = { navController.popBackStack() })&#10;        }&#10;&#10;        composable(&#10;            route = Destinations.TERRARIUM_DETAIL_ROUTE,&#10;            arguments = listOf(navArgument(Destinations.TERRARIUM_ID_ARG) {&#10;                type = NavType.StringType&#10;            })&#10;        ) { backStackEntry -&gt;&#10;            val terrariumId = backStackEntry.arguments?.getString(Destinations.TERRARIUM_ID_ARG)&#10;            if (terrariumId != null) {&#10;                TerrariumDetailScreen(&#10;                    terrariumId = terrariumId,&#10;                    onBackClick = { navController.popBackStack() }&#10;                )&#10;            } else {&#10;                Log.e(&quot;AppNavHost&quot;, &quot;Terrarium ID is null for detail route&quot;)&#10;                navController.popBackStack()&#10;            }&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_CREDENTIALS) {&#10;            CredentialsScreen(&#10;                onNextClick = { navController.navigate(Destinations.BLUETOOTH_SCAN_ROUTE) },&#10;                onBackClick = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // Define una pantalla en el NavHost con la ruta &quot;bluetooth_scan_route&quot;&#10;        composable(Destinations.BLUETOOTH_SCAN_ROUTE) {&#10;&#10;            // Llama al Composable que dibuja la pantalla de escaneo Bluetooth&#10;            BluetoothScanScreen(&#10;                // Pasa el parámetro nombrado &quot;onBackClick&quot; que es una función lambda&#10;                // BluetoothScanScreen está definida para recibir este parámetro como función:&#10;                //    fun BluetoothScanScreen(onBackClick: () -&gt; Unit) { ... }&#10;                // Por eso debemos proporcionarle esta función para manejar el evento &quot;volver&quot;&#10;                onBackClick = {&#10;                    // Dentro de la lambda, se llama a navController.popBackStack()&#10;                    // Esto hace que la navegación regrese a la pantalla anterior en la pila de navegación&#10;                    navController.popBackStack()&#10;                },&#10;                onNavigateToWiFi = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_WIFI)&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_WIFI) {&#10;            WiFiScanScreen(&#10;                onBackClick = { navController.popBackStack() },&#10;                onNavigateHome = {&#10;                    navController.navigate(Destinations.HOME_ROUTE) {&#10;                        popUpTo(Destinations.HOME_ROUTE) { inclusive = false }&#10;                    }&#10;                },&#10;                onNavigateToSendingScreen = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_SENDING)&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_SENDING) {&#10;            ProvisioningProcessScreen(&#10;                onProvisioningSuccess = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_CHECKPOINT)&#10;                },&#10;                onNavigateToHome = {&#10;                    navController.navigate(Destinations.HOME_ROUTE) {&#10;                        popUpTo(Destinations.HOME_ROUTE) { inclusive = false }&#10;                    }&#10;                },&#10;                onNavigateToCompleted = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_COMPLETED) {&#10;                        popUpTo(Destinations.HOME_ROUTE) { inclusive = true }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_CHECKPOINT) {&#10;            CheckpointScreen(&#10;                onContinueClick = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_CREDENTIALS) {&#10;                        popUpTo(Destinations.TERRARIUM_SETUP_CHECKPOINT) {&#10;                            inclusive = true&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_COMPLETED) {&#10;            SetupCompletedScreen(&#10;                onContinueClick = {&#10;                    navController.navigate(Destinations.HOME_ROUTE) {&#10;                        popUpTo(Destinations.HOME_ROUTE) {&#10;                            inclusive = false&#10;                        }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.navigation&#10;&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.navArgument&#10;import com.waldoz_x.reptitrack.presentation.wifi.WiFiScanScreen&#10;import com.waldoz_x.reptitrack.ui.screens.home.HomeRoute&#10;import com.waldoz_x.reptitrack.ui.screens.settings.SettingsScreen&#10;import com.waldoz_x.reptitrack.ui.screens.timezone.TimeZoneSelectionScreen&#10;import com.waldoz_x.reptitrack.ui.screens.countryregion.CountryRegionSelectionScreen&#10;import com.waldoz_x.reptitrack.ui.screens.mqtt.MqttSettingsScreen&#10;import com.waldoz_x.reptitrack.ui.screens.terrariumdetail.TerrariumDetailScreen&#10;import com.waldoz_x.reptitrack.ui.screens.provisioning.*&#10;&#10;&#10;// Define las rutas de navegación como constantes para evitar errores de tipeo&#10;object Destinations {&#10;    const val HOME_ROUTE = &quot;home_route&quot;&#10;    const val SETTINGS_ROUTE = &quot;settings_route&quot;&#10;    const val TIME_ZONE_SELECTION_ROUTE = &quot;time_zone_selection_route&quot;&#10;    const val COUNTRY_REGION_SELECTION_ROUTE = &quot;country_region_selection_route&quot;&#10;    const val MQTT_SETTINGS_ROUTE = &quot;mqtt_settings_route&quot;&#10;&#10;    const val TERRARIUM_ID_ARG = &quot;terrariumId&quot;&#10;    const val TERRARIUM_DETAIL_ROUTE = &quot;terrarium_detail_route/{$TERRARIUM_ID_ARG}&quot;&#10;&#10;    const val TERRARIUM_SETUP_CREDENTIALS = &quot;terrarium_setup_credentials&quot;&#10;    const val BLUETOOTH_SCAN_ROUTE = &quot;bluetooth_scan_route&quot;&#10;    const val TERRARIUM_SETUP_WIFI = &quot;terrarium_setup_wifi&quot;&#10;    const val TERRARIUM_SETUP_SENDING = &quot;terrarium_setup_sending&quot;&#10;    const val TERRARIUM_SETUP_CHECKPOINT = &quot;terrarium_setup_checkpoint&quot;&#10;    const val TERRARIUM_SETUP_COMPLETED = &quot;terrarium_setup_completed&quot;&#10;}&#10;&#10;@Composable&#10;fun AppNavHost(&#10;    navController: NavHostController,&#10;    modifier: Modifier = Modifier,&#10;    startDestination: String = Destinations.HOME_ROUTE&#10;) {&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = startDestination,&#10;        modifier = modifier&#10;    ) {&#10;        composable(Destinations.HOME_ROUTE) {&#10;            HomeRoute(&#10;                navigateToTerrariumDetail = { terrariumId -&gt;&#10;                    navController.navigate(&#10;                        Destinations.TERRARIUM_DETAIL_ROUTE.replace(&#10;                            &quot;{${Destinations.TERRARIUM_ID_ARG}}&quot;, terrariumId&#10;                        )&#10;                    )&#10;                },&#10;                navigateToSettings = { navController.navigate(Destinations.SETTINGS_ROUTE) },&#10;                onAddTerrarium = { navController.navigate(Destinations.TERRARIUM_SETUP_CREDENTIALS) }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.SETTINGS_ROUTE) {&#10;            SettingsScreen(&#10;                onBackClick = { navController.popBackStack() },&#10;                navigateToTimeZoneSelection = { navController.navigate(Destinations.TIME_ZONE_SELECTION_ROUTE) },&#10;                navigateToCountryRegionSelection = { navController.navigate(Destinations.COUNTRY_REGION_SELECTION_ROUTE) },&#10;                navigateToMqttSettings = { navController.navigate(Destinations.MQTT_SETTINGS_ROUTE) },&#10;                navigateToTerrariumDetailPlaceholder = {&#10;                    navController.navigate(&#10;                        Destinations.TERRARIUM_DETAIL_ROUTE.replace(&#10;                            &quot;{${Destinations.TERRARIUM_ID_ARG}}&quot;, &quot;Ipzro9ETmRX9moHzQ0QNXv06SBy1&quot;&#10;                        )&#10;                    )&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TIME_ZONE_SELECTION_ROUTE) {&#10;            TimeZoneSelectionScreen(onBackClick = { navController.popBackStack() })&#10;        }&#10;&#10;        composable(Destinations.COUNTRY_REGION_SELECTION_ROUTE) {&#10;            CountryRegionSelectionScreen(onBackClick = { navController.popBackStack() })&#10;        }&#10;&#10;        composable(Destinations.MQTT_SETTINGS_ROUTE) {&#10;            MqttSettingsScreen(onBackClick = { navController.popBackStack() })&#10;        }&#10;&#10;        composable(&#10;            route = Destinations.TERRARIUM_DETAIL_ROUTE,&#10;            arguments = listOf(navArgument(Destinations.TERRARIUM_ID_ARG) {&#10;                type = NavType.StringType&#10;            })&#10;        ) { backStackEntry -&gt;&#10;            val terrariumId = backStackEntry.arguments?.getString(Destinations.TERRARIUM_ID_ARG)&#10;            if (terrariumId != null) {&#10;                TerrariumDetailScreen(&#10;                    terrariumId = terrariumId,&#10;                    onBackClick = { navController.popBackStack() }&#10;                )&#10;            } else {&#10;                Log.e(&quot;AppNavHost&quot;, &quot;Terrarium ID is null for detail route&quot;)&#10;                navController.popBackStack()&#10;            }&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_CREDENTIALS) {&#10;            CredentialsScreen(&#10;                onNextClick = { navController.navigate(Destinations.BLUETOOTH_SCAN_ROUTE) },&#10;                onBackClick = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // Define una pantalla en el NavHost con la ruta &quot;bluetooth_scan_route&quot;&#10;        composable(Destinations.BLUETOOTH_SCAN_ROUTE) {&#10;&#10;            // Llama al Composable que dibuja la pantalla de escaneo Bluetooth&#10;            BluetoothScanScreen(&#10;                // Pasa el parámetro nombrado &quot;onBackClick&quot; que es una función lambda&#10;                // BluetoothScanScreen está definida para recibir este parámetro como función:&#10;                //    fun BluetoothScanScreen(onBackClick: () -&gt; Unit) { ... }&#10;                // Por eso debemos proporcionarle esta función para manejar el evento &quot;volver&quot;&#10;                onBackClick = {&#10;                    // Dentro de la lambda, se llama a navController.popBackStack()&#10;                    // Esto hace que la navegación regrese a la pantalla anterior en la pila de navegación&#10;                    navController.popBackStack()&#10;                },&#10;                onNavigateToWiFi = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_WIFI)&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_WIFI) {&#10;            WiFiScanScreen(&#10;                onBackClick = { navController.popBackStack() },&#10;                onNavigateHome = {&#10;                    navController.navigate(Destinations.HOME_ROUTE) {&#10;                        popUpTo(Destinations.HOME_ROUTE) { inclusive = false }&#10;                    }&#10;                },&#10;                onNavigateToSendingScreen = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_SENDING)&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_SENDING) {&#10;            ProvisioningProcessScreen(&#10;                onProvisioningSuccess = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_CHECKPOINT)&#10;                },&#10;                onNavigateToHome = {&#10;                    navController.navigate(Destinations.HOME_ROUTE) {&#10;                        popUpTo(Destinations.HOME_ROUTE) { inclusive = false }&#10;                    }&#10;                },&#10;                onNavigateToCompleted = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_COMPLETED) {&#10;                        popUpTo(Destinations.HOME_ROUTE) { inclusive = true }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_CHECKPOINT) {&#10;            CheckpointScreen(&#10;                onContinueClick = {&#10;                    navController.navigate(Destinations.TERRARIUM_SETUP_CREDENTIALS) {&#10;                        popUpTo(Destinations.TERRARIUM_SETUP_CHECKPOINT) {&#10;                            inclusive = true&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        composable(Destinations.TERRARIUM_SETUP_COMPLETED) {&#10;            SetupCompletedScreen(&#10;                onContinueClick = {&#10;                    navController.navigate(Destinations.HOME_ROUTE) {&#10;                        popUpTo(Destinations.HOME_ROUTE) {&#10;                            inclusive = false&#10;                        }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/Dht22SensorCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/Dht22SensorCard.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.components&#10;&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.painter.Painter&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import com.waldoz_x.reptitrack.R&#10;&#10;// Helper function to get health color (copied from TerrariumDetailScreen for self-containment)&#10;@Composable&#10;fun getHealthColor(value: Float?, sensorType: String): Color {&#10;    if (value == null) return Color.LightGray.copy(alpha = 0.6f)&#10;&#10;    return when (sensorType) {&#10;        &quot;temperature&quot; -&gt; {&#10;            when {&#10;                value &lt; 20.0f -&gt; Color(0xFFADD8E6) // Light Blue (Cold)&#10;                value &gt; 30.0f -&gt; Color(0xFFFFA07A) // Light Salmon (Hot)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        &quot;humidity&quot; -&gt; {&#10;            when {&#10;                value &lt; 50.0f -&gt; Color(0xFFFFA07A) // Light Salmon (Dry)&#10;                value &gt; 80.0f -&gt; Color(0xFFADD8E6) // Light Blue (Humid)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        else -&gt; Color.White // Default&#10;    }&#10;}&#10;&#10;// Helper function to get sensor icons (copied from TerrariumDetailScreen for self-containment)&#10;@Composable&#10;fun getSensorIcon(sensorType: String): Painter {&#10;    return when (sensorType) {&#10;        &quot;temperature&quot; -&gt; painterResource(id = R.drawable.ic_baseline_thermostat_24)&#10;        &quot;humidity&quot; -&gt; painterResource(id = R.drawable.ic_outline_humidity_high_24)&#10;        else -&gt; painterResource(id = R.drawable.ic_baseline_cloud_24) // Generic placeholder&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Dht22SensorCard(sensorNumber: Int, sensorData: Map&lt;String, String&gt;) {&#10;    val tempKey = &quot;dht22_${sensorNumber}_temperature&quot;&#10;    val humKey = &quot;dht22_${sensorNumber}_humidity&quot;&#10;    val temperatureValue = sensorData[tempKey]?.replace(&quot;°C&quot;, &quot;&quot;)?.toFloatOrNull()&#10;    val humidityValue = sensorData[humKey]?.replace(&quot;%&quot;, &quot;&quot;)?.toFloatOrNull()&#10;&#10;    val temperatureText = sensorData[tempKey] ?: &quot;N/A&quot;&#10;    val humidityText = sensorData[humKey] ?: &quot;N/A&quot;&#10;&#10;    val tempColor = getHealthColor(temperatureValue, &quot;temperature&quot;)&#10;    val humColor = getHealthColor(humidityValue, &quot;humidity&quot;)&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .width(180.dp)&#10;            .height(160.dp)&#10;            .padding(8.dp),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(4.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF607D8B).copy(alpha = 0.7f))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(12.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;DHT22 Sensor $sensorNumber&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                textAlign = TextAlign.Center,&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(&#10;                    painter = getSensorIcon(&quot;temperature&quot;),&#10;                    contentDescription = &quot;Temperatura&quot;,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;                Text(&#10;                    text = temperatureText,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = tempColor&#10;                )&#10;                if (temperatureValue != null) {&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Canvas(modifier = Modifier.size(8.dp), onDraw = {&#10;                        drawCircle(color = tempColor)&#10;                    })&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(&#10;                    painter = getSensorIcon(&quot;humidity&quot;),&#10;                    contentDescription = &quot;Humedad&quot;,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;                Text(&#10;                    text = humidityText,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = humColor&#10;                )&#10;                if (humidityValue != null) {&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Canvas(modifier = Modifier.size(8.dp), onDraw = {&#10;                        drawCircle(color = humColor)&#10;                    })&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.components&#10;&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.painter.Painter&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import com.waldoz_x.reptitrack.R&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getHealthColor&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getSensorIcon&#10;&#10;@Composable&#10;fun Dht22SensorCard(sensorNumber: Int, sensorData: Map&lt;String, String&gt;) {&#10;    val tempKey = &quot;dht22_${sensorNumber}_temperature&quot;&#10;    val humKey = &quot;dht22_${sensorNumber}_humidity&quot;&#10;    val temperatureValue = sensorData[tempKey]?.replace(&quot;°C&quot;, &quot;&quot;)?.toFloatOrNull()&#10;    val humidityValue = sensorData[humKey]?.replace(&quot;%&quot;, &quot;&quot;)?.toFloatOrNull()&#10;&#10;    val temperatureText = sensorData[tempKey] ?: &quot;N/A&quot;&#10;    val humidityText = sensorData[humKey] ?: &quot;N/A&quot;&#10;&#10;    val tempColor = getHealthColor(temperatureValue, &quot;temperature&quot;)&#10;    val humColor = getHealthColor(humidityValue, &quot;humidity&quot;)&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .width(180.dp)&#10;            .height(160.dp)&#10;            .padding(8.dp),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(4.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF607D8B).copy(alpha = 0.7f))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(12.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;DHT22 Sensor $sensorNumber&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White,&#10;                textAlign = TextAlign.Center,&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(&#10;                    painter = getSensorIcon(&quot;temperature&quot;),&#10;                    contentDescription = &quot;Temperatura&quot;,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;                Text(&#10;                    text = temperatureText,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = tempColor&#10;                )&#10;                if (temperatureValue != null) {&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Canvas(modifier = Modifier.size(8.dp), onDraw = {&#10;                        drawCircle(color = tempColor)&#10;                    })&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(&#10;                    painter = getSensorIcon(&quot;humidity&quot;),&#10;                    contentDescription = &quot;Humedad&quot;,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;                Text(&#10;                    text = humidityText,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = humColor&#10;                )&#10;                if (humidityValue != null) {&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Canvas(modifier = Modifier.size(8.dp), onDraw = {&#10;                        drawCircle(color = humColor)&#10;                    })&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/Dht22SensorGroupCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/Dht22SensorGroupCard.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.components&#10;&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.tooling.preview.Preview // Importar la anotación Preview&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.sp // Importar para usar sp en el tamaño de fuente&#10;// Importar las funciones reales de sensorUtils&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getHealthColor&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getSensorIcon&#10;import androidx.compose.ui.res.painterResource&#10;import com.waldoz_x.reptitrack.R&#10;&#10;// --- Tu Composable original modificado para ser más compacto ---&#10;@Composable&#10;fun Dht22SensorGroupCard(&#10;    sensorNumber: Int,&#10;    sensorData: Map&lt;String, String&gt;,&#10;    hasMqttData: Boolean = false // &lt;- este parámetro ya no se usa&#10;) {&#10;    val tempKey = &quot;dht22_${sensorNumber}_temperature&quot;&#10;    val humKey = &quot;dht22_${sensorNumber}_humidity&quot;&#10;    val temperatureValue = sensorData[tempKey]?.replace(&quot;°C&quot;, &quot;&quot;)?.toFloatOrNull()&#10;    val humidityValue = sensorData[humKey]?.replace(&quot;%&quot;, &quot;&quot;)?.toFloatOrNull()&#10;&#10;    // Si no hay datos, muestra &quot;N/A&quot;&#10;    val temperatureText = sensorData[tempKey]?.takeIf { it != &quot;&quot; &amp;&amp; it != &quot;null&quot; } ?: &quot;N/A&quot;&#10;    val humidityText = sensorData[humKey]?.takeIf { it != &quot;&quot; &amp;&amp; it != &quot;null&quot; } ?: &quot;N/A&quot;&#10;&#10;    val tempColor = getHealthColor(temperatureValue, &quot;temperature&quot;)&#10;    val humColor = getHealthColor(humidityValue, &quot;humidity&quot;)&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .width(200.dp)&#10;            .height(130.dp)&#10;            .padding(8.dp),&#10;        shape = RoundedCornerShape(20.dp),&#10;        elevation = CardDefaults.cardElevation(6.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF2C3E50).copy(alpha = 0.7f))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(id = getSensorIcon(&quot;temperature&quot;)),&#10;                    contentDescription = &quot;Temperatura&quot;,&#10;                    modifier = Modifier.size(32.dp),&#10;                    tint = Color.White&#10;                )&#10;                Spacer(modifier = Modifier.width(10.dp))&#10;                Text(&#10;                    text = temperatureText,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(fontSize = 22.sp),&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = tempColor&#10;                )&#10;                if (temperatureValue != null) {&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Canvas(modifier = Modifier.size(12.dp), onDraw = {&#10;                        drawCircle(color = tempColor)&#10;                    })&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(id = getSensorIcon(&quot;humidity&quot;)),&#10;                    contentDescription = &quot;Humedad&quot;,&#10;                    modifier = Modifier.size(32.dp),&#10;                    tint = Color.White&#10;                )&#10;                Spacer(modifier = Modifier.width(10.dp))&#10;                Text(&#10;                    text = humidityText,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(fontSize = 22.sp),&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = humColor&#10;                )&#10;                if (humidityValue != null) {&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Canvas(modifier = Modifier.size(12.dp), onDraw = {&#10;                        drawCircle(color = humColor)&#10;                    })&#10;                }&#10;            }&#10;            // ...NO mostrar mensaje de &quot;Esperando datos...&quot;...&#10;        }&#10;    }&#10;}&#10;&#10;// --- Función de Preview ---&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun PreviewDht22SensorGroupCard() {&#10;    // Para el preview, puedes simular datos de sensor&#10;    val sampleSensorData1 = mapOf(&#10;        &quot;dht22_1_temperature&quot; to &quot;25.5°C&quot;,&#10;        &quot;dht22_1_humidity&quot; to &quot;60.2%&quot;&#10;    )&#10;    val sampleSensorData2 = mapOf(&#10;        &quot;dht22_2_temperature&quot; to &quot;18.0°C&quot;, // Temperatura fuera de rango para mostrar color rojo&#10;        &quot;dht22_2_humidity&quot; to &quot;80.0%&quot;    // Humedad fuera de rango para mostrar color rojo&#10;    )&#10;    val sampleSensorData3 = mapOf(&#10;        &quot;dht22_3_temperature&quot; to &quot;N/A&quot;, // Datos no disponibles&#10;        &quot;dht22_3_humidity&quot; to &quot;N/A&quot;&#10;    )&#10;&#10;    // Puedes envolverlo en un tema si tu aplicación usa un tema personalizado&#10;    MaterialTheme {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Dht22SensorGroupCard(sensorNumber = 1, sensorData = sampleSensorData1)&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Dht22SensorGroupCard(sensorNumber = 2, sensorData = sampleSensorData2)&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Dht22SensorGroupCard(sensorNumber = 3, sensorData = sampleSensorData3)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.components&#10;&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.tooling.preview.Preview // Importar la anotación Preview&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.sp // Importar para usar sp en el tamaño de fuente&#10;// Importar las funciones reales de sensorUtils&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getHealthColor&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getSensorIcon&#10;import androidx.compose.ui.res.painterResource&#10;import com.waldoz_x.reptitrack.R&#10;&#10;// --- Tu Composable original modificado para ser más compacto ---&#10;@Composable&#10;fun Dht22SensorGroupCard(&#10;    sensorNumber: Int,&#10;    sensorData: Map&lt;String, String&gt;,&#10;    hasMqttData: Boolean = false // &lt;- este parámetro ya no se usa&#10;) {&#10;    val tempKey = &quot;dht22_${sensorNumber}_temperature&quot;&#10;    val humKey = &quot;dht22_${sensorNumber}_humidity&quot;&#10;    val temperatureValue = sensorData[tempKey]?.replace(&quot;°C&quot;, &quot;&quot;)?.toFloatOrNull()&#10;    val humidityValue = sensorData[humKey]?.replace(&quot;%&quot;, &quot;&quot;)?.toFloatOrNull()&#10;&#10;    // Si no hay datos, muestra &quot;N/A&quot;&#10;    val temperatureText = sensorData[tempKey]?.takeIf { !it.isNullOrBlank() &amp;&amp; it != &quot;null&quot; } ?: &quot;N/A&quot;&#10;    val humidityText = sensorData[humKey]?.takeIf { !it.isNullOrBlank() &amp;&amp; it != &quot;null&quot; } ?: &quot;N/A&quot;&#10;&#10;    val tempColor = getHealthColor(temperatureValue, &quot;temperature&quot;)&#10;    val humColor = getHealthColor(humidityValue, &quot;humidity&quot;)&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .width(200.dp)&#10;            .height(130.dp)&#10;            .padding(8.dp),&#10;        shape = RoundedCornerShape(20.dp),&#10;        elevation = CardDefaults.cardElevation(6.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF2C3E50).copy(alpha = 0.7f))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(id = getSensorIcon(&quot;temperature&quot;)),&#10;                    contentDescription = &quot;Temperatura&quot;,&#10;                    modifier = Modifier.size(32.dp),&#10;                    tint = Color.White&#10;                )&#10;                Spacer(modifier = Modifier.width(10.dp))&#10;                Text(&#10;                    text = temperatureText,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(fontSize = 22.sp),&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = tempColor&#10;                )&#10;                if (temperatureValue != null) {&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Canvas(modifier = Modifier.size(12.dp), onDraw = {&#10;                        drawCircle(color = tempColor)&#10;                    })&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.Center,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Icon(&#10;                    painter = painterResource(id = getSensorIcon(&quot;humidity&quot;)),&#10;                    contentDescription = &quot;Humedad&quot;,&#10;                    modifier = Modifier.size(32.dp),&#10;                    tint = Color.White&#10;                )&#10;                Spacer(modifier = Modifier.width(10.dp))&#10;                Text(&#10;                    text = humidityText,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(fontSize = 22.sp),&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = humColor&#10;                )&#10;                if (humidityValue != null) {&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Canvas(modifier = Modifier.size(12.dp), onDraw = {&#10;                        drawCircle(color = humColor)&#10;                    })&#10;                }&#10;            }&#10;            // ...NO mostrar mensaje de &quot;Esperando datos...&quot;...&#10;        }&#10;    }&#10;}&#10;&#10;// --- Función de Preview ---&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun PreviewDht22SensorGroupCard() {&#10;    // Para el preview, puedes simular datos de sensor&#10;    val sampleSensorData1 = mapOf(&#10;        &quot;dht22_1_temperature&quot; to &quot;25.5°C&quot;,&#10;        &quot;dht22_1_humidity&quot; to &quot;60.2%&quot;&#10;    )&#10;    val sampleSensorData2 = mapOf(&#10;        &quot;dht22_2_temperature&quot; to &quot;18.0°C&quot;, // Temperatura fuera de rango para mostrar color rojo&#10;        &quot;dht22_2_humidity&quot; to &quot;80.0%&quot;    // Humedad fuera de rango para mostrar color rojo&#10;    )&#10;    val sampleSensorData3 = mapOf(&#10;        &quot;dht22_3_temperature&quot; to &quot;N/A&quot;, // Datos no disponibles&#10;        &quot;dht22_3_humidity&quot; to &quot;N/A&quot;&#10;    )&#10;&#10;    // Puedes envolverlo en un tema si tu aplicación usa un tema personalizado&#10;    MaterialTheme {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Dht22SensorGroupCard(sensorNumber = 1, sensorData = sampleSensorData1)&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Dht22SensorGroupCard(sensorNumber = 2, sensorData = sampleSensorData2)&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Dht22SensorGroupCard(sensorNumber = 3, sensorData = sampleSensorData3)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/Ds18b20SensorGroupCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/Ds18b20SensorGroupCard.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.components&#10;&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.tooling.preview.Preview // Importar la anotación Preview&#10;import androidx.compose.ui.unit.sp // Importar para usar sp en el tamaño de fuente&#10;import androidx.compose.foundation.layout.FlowRow // ¡Importación actualizada a la versión nativa de Compose!&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getHealthColor&#10;import androidx.compose.ui.res.painterResource&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getSensorIcon&#10;&#10;@Composable&#10;fun Ds18b20SensorGroupCard(&#10;    sensorData: Map&lt;String, String&gt;,&#10;    hasMqttData: Boolean = false // Nuevo parámetro&#10;) {&#10;    // No filtrar, siempre mostrar los 5 sensores&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp)&#10;            .animateContentSize(animationSpec = tween(durationMillis = 300)), // Animación para el tamaño del contenido&#10;        shape = RoundedCornerShape(20.dp), // Bordes más redondeados&#10;        elevation = CardDefaults.cardElevation(6.dp), // Sombra consistente&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF2C3E50).copy(alpha = 0.7f)) // Tono oscuro y transparente&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp) // Más padding interno&#10;        ) {&#10;            Text(&#10;                text = &quot;Sensores de Temperatura&quot;, // Nombre más amigable&#10;                style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp), // Tamaño de fuente más grande&#10;                fontWeight = FontWeight.ExtraBold, // Más énfasis&#10;                color = Color.White,&#10;                modifier = Modifier.padding(bottom = 12.dp) // Más espacio debajo del título&#10;            )&#10;            FlowRow(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center, // Centrar los elementos en el FlowRow&#10;                verticalArrangement = Arrangement.spacedBy(16.dp) // Más espacio vertical entre elementos&#10;            ) {&#10;                // Iterar hasta 5 sensores, o menos si no hay datos&#10;                for (i in 1..5) {&#10;                    val key = &quot;ds18b20_${i}_temperature&quot;&#10;                    val value = sensorData[key]?.takeIf { it != &quot;&quot; &amp;&amp; it != &quot;null&quot; } ?: &quot;N/A&quot;&#10;                    val tempValue = value.replace(&quot;°C&quot;, &quot;&quot;).toFloatOrNull()&#10;                    val tempColor = getHealthColor(tempValue, &quot;temperature&quot;)&#10;&#10;                    // Nuevo diseño para cada ítem de temperatura&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        modifier = Modifier&#10;                            .padding(horizontal = 12.dp) // Más espacio horizontal para cada columna&#10;                            .width(IntrinsicSize.Min) // Asegura que la columna se ajuste a su contenido&#10;                    ) {&#10;                        Icon(&#10;                            painter = painterResource(id = getSensorIcon(&quot;temperature&quot;)),&#10;                            contentDescription = &quot;Temperatura&quot;,&#10;                            modifier = Modifier.size(36.dp),&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.height(6.dp)) // Espacio entre ícono y etiqueta&#10;                        Text(&#10;                            text = &quot;Temp $i&quot;, // Etiqueta del sensor&#10;                            style = MaterialTheme.typography.bodyMedium.copy(fontSize = 15.sp), // Tamaño de fuente ligeramente más grande&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = Color.LightGray,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                        Spacer(modifier = Modifier.height(2.dp)) // Espacio entre etiqueta y valor&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            horizontalArrangement = Arrangement.Center&#10;                        ) {&#10;                            Text(&#10;                                text = value,&#10;                                style = MaterialTheme.typography.headlineSmall.copy(fontSize = 24.sp), // Tamaño de fuente más grande para el valor&#10;                                fontWeight = FontWeight.ExtraBold, // Más énfasis en el valor&#10;                                color = tempColor&#10;                            )&#10;                            if (tempValue != null) {&#10;                                Spacer(modifier = Modifier.width(6.dp))&#10;                                Canvas(modifier = Modifier.size(12.dp), onDraw = { // Círculo un poco más grande&#10;                                    drawCircle(color = tempColor)&#10;                                })&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            if (!hasMqttData) {&#10;                Text(&#10;                    text = &quot;Esperando datos de sensores DS18B20...&quot;,&#10;                    color = Color.LightGray,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// --- Función de Preview para Ds18b20SensorGroupCard ---&#10;@Preview(showBackground = true, widthDp = 400) // Ancho para ver el FlowRow&#10;@Composable&#10;fun PreviewDs18b20SensorGroupCard() {&#10;    // Datos de ejemplo para el preview&#10;    val sampleSensorData = mapOf(&#10;        &quot;ds18b20_1_temperature&quot; to &quot;22.3°C&quot;,&#10;        &quot;ds18b20_2_temperature&quot; to &quot;28.1°C&quot;,&#10;        &quot;ds18b20_3_temperature&quot; to &quot;19.5°C&quot;,&#10;        &quot;ds18b20_4_temperature&quot; to &quot;31.0°C&quot;, // Fuera de rango para mostrar color&#10;        &quot;ds18b20_5_temperature&quot; to &quot;24.8°C&quot;&#10;    )&#10;&#10;    val emptySensorData = mapOf&lt;String, String&gt;() // Datos vacíos para probar el mensaje &quot;N/A&quot;&#10;&#10;    MaterialTheme {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Ejemplo con datos:&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;            Ds18b20SensorGroupCard(sensorData = sampleSensorData)&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            Text(&#10;                text = &quot;Ejemplo sin datos:&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;            Ds18b20SensorGroupCard(sensorData = emptySensorData)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.components&#10;&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.tooling.preview.Preview // Importar la anotación Preview&#10;import androidx.compose.ui.unit.sp // Importar para usar sp en el tamaño de fuente&#10;import androidx.compose.foundation.layout.FlowRow // ¡Importación actualizada a la versión nativa de Compose!&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getHealthColor&#10;import androidx.compose.ui.res.painterResource&#10;import com.waldoz_x.reptitrack.ui.components.sensorUtils.getSensorIcon&#10;&#10;@Composable&#10;fun Ds18b20SensorGroupCard(&#10;    sensorData: Map&lt;String, String&gt;,&#10;    hasMqttData: Boolean = false // &lt;- este parámetro ya no se usa&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp)&#10;            .animateContentSize(animationSpec = tween(durationMillis = 300)),&#10;        shape = RoundedCornerShape(20.dp),&#10;        elevation = CardDefaults.cardElevation(6.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF2C3E50).copy(alpha = 0.7f))&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Sensores de Temperatura&quot;,&#10;                style = MaterialTheme.typography.titleLarge.copy(fontSize = 20.sp),&#10;                fontWeight = FontWeight.ExtraBold,&#10;                color = Color.White,&#10;                modifier = Modifier.padding(bottom = 12.dp)&#10;            )&#10;            FlowRow(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                for (i in 1..5) {&#10;                    val key = &quot;ds18b20_${i}_temperature&quot;&#10;                    val value = sensorData[key]?.takeIf { it != &quot;&quot; &amp;&amp; it != &quot;null&quot; } ?: &quot;N/A&quot;&#10;                    val tempValue = value.replace(&quot;°C&quot;, &quot;&quot;).toFloatOrNull()&#10;                    val tempColor = getHealthColor(tempValue, &quot;temperature&quot;)&#10;&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        modifier = Modifier&#10;                            .padding(horizontal = 12.dp)&#10;                            .width(IntrinsicSize.Min)&#10;                    ) {&#10;                        Icon(&#10;                            painter = painterResource(id = getSensorIcon(&quot;temperature&quot;)),&#10;                            contentDescription = &quot;Temperatura&quot;,&#10;                            modifier = Modifier.size(36.dp),&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.height(6.dp))&#10;                        Text(&#10;                            text = &quot;Temp $i&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(fontSize = 15.sp),&#10;                            fontWeight = FontWeight.SemiBold,&#10;                            color = Color.LightGray,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                        Spacer(modifier = Modifier.height(2.dp))&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically,&#10;                            horizontalArrangement = Arrangement.Center&#10;                        ) {&#10;                            Text(&#10;                                text = value,&#10;                                style = MaterialTheme.typography.headlineSmall.copy(fontSize = 24.sp),&#10;                                fontWeight = FontWeight.ExtraBold,&#10;                                color = tempColor&#10;                            )&#10;                            if (tempValue != null) {&#10;                                Spacer(modifier = Modifier.width(6.dp))&#10;                                Canvas(modifier = Modifier.size(12.dp), onDraw = {&#10;                                    drawCircle(color = tempColor)&#10;                                })&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// --- Función de Preview para Ds18b20SensorGroupCard ---&#10;@Preview(showBackground = true, widthDp = 400) // Ancho para ver el FlowRow&#10;@Composable&#10;fun PreviewDs18b20SensorGroupCard() {&#10;    // Datos de ejemplo para el preview&#10;    val sampleSensorData = mapOf(&#10;        &quot;ds18b20_1_temperature&quot; to &quot;22.3°C&quot;,&#10;        &quot;ds18b20_2_temperature&quot; to &quot;28.1°C&quot;,&#10;        &quot;ds18b20_3_temperature&quot; to &quot;19.5°C&quot;,&#10;        &quot;ds18b20_4_temperature&quot; to &quot;31.0°C&quot;, // Fuera de rango para mostrar color&#10;        &quot;ds18b20_5_temperature&quot; to &quot;24.8°C&quot;&#10;    )&#10;&#10;    val emptySensorData = mapOf&lt;String, String&gt;() // Datos vacíos para probar el mensaje &quot;N/A&quot;&#10;&#10;    MaterialTheme {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(&#10;                text = &quot;Ejemplo con datos:&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;            Ds18b20SensorGroupCard(sensorData = sampleSensorData)&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            Text(&#10;                text = &quot;Ejemplo sin datos:&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;            Ds18b20SensorGroupCard(sensorData = emptySensorData)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/TerrariumCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/TerrariumCard.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.components&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview // Important for @Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import com.waldoz_x.reptitrack.R // Ensure R is available for drawables&#10;&#10;// Composable to display a compact visual card of a terrarium.&#10;// Composable para mostrar una tarjeta visual compacta de un terrario.&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TerrariumCard(&#10;    terrarium: Terrarium,&#10;    modifier: Modifier = Modifier,&#10;    onClick: (String) -&gt; Unit // Callback for when the card is clicked&#10;) {&#10;    val cardBackgroundColor = Color.Black.copy(alpha = 0.7f) // Adjusted alpha for more darkness&#10;&#10;    Card(&#10;        modifier = modifier&#10;            .width(180.dp) // Fixed width for two columns layout&#10;            .padding(8.dp) // Reduced outer padding&#10;            .clickable { onClick(terrarium.id) }, // Makes the card clickable&#10;        elevation = CardDefaults.cardElevation(4.dp),&#10;        shape = RoundedCornerShape(16.dp), // Rounded corners&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = cardBackgroundColor // Fixed dark transparent background&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 8.dp, vertical = 12.dp), // Adjusted horizontal padding to give more space&#10;            horizontalAlignment = Alignment.CenterHorizontally // Centers content horizontally&#10;        ) {&#10;            // Terrarium image&#10;            // Imagen del terrario&#10;            Image(&#10;                painter = painterResource(id = terrarium.imageResId ?: R.drawable.terrario),&#10;                contentDescription = &quot;Imagen del terrario ${terrarium.name}&quot;,&#10;                modifier = Modifier&#10;                    .size(80.dp)&#10;                    .clip(RoundedCornerShape(8.dp)), // Elimina el background oscuro&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Terrarium name - fixed color (e.g., white or light gray)&#10;            // Nombre del terrario - color fijo (ej. blanco o gris claro)&#10;            Text(&#10;                text = terrarium.name,&#10;                style = MaterialTheme.typography.titleMedium, // Medium title size&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White, // Fixed white color for the name&#10;                maxLines = 1, // Limit to one line for small cards&#10;                overflow = TextOverflow.Ellipsis // Add ellipsis if text is too long&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            // DHT22 readings (Temperature and Humidity)&#10;            // Lecturas del DHT22 (Temperatura y Humedad)&#10;            val tempDHT = terrarium.dht22_1_temperature&#10;            val humDHT = terrarium.dht22_1_humidity&#10;&#10;            // Function to get color based on temperature&#10;            // Función para obtener el color basado en la temperatura&#10;            fun getTemperatureColor(temp: Float?): Color {&#10;                return when (temp) {&#10;                    null -&gt; Color.Gray // N/A color&#10;                    in 0f..17f -&gt; Color(0xFF2196F3) // Blue for very cold&#10;                    in 17.1f..22f -&gt; Color(0xFF03A9F4) // Lighter blue for cold&#10;                    in 22.1f..27f -&gt; Color(0xFF8BC34A) // Green for ideal/normal&#10;                    in 27.1f..32f -&gt; Color(0xFFFFC107) // Orange for warm&#10;                    else -&gt; Color(0xFFF44336) // Red for hot&#10;                }&#10;            }&#10;&#10;            // Function to get color based on humidity&#10;            // Función para obtener el color basado en la humedad&#10;            fun getHumidityColor(humidity: Float?): Color {&#10;                return when (humidity) {&#10;                    null -&gt; Color.Gray // N/A color&#10;                    in 0f..30f -&gt; Color(0xFFEF5350) // Red for very dry&#10;                    in 30.1f..50f -&gt; Color(0xFFFF9800) // Orange for dry&#10;                    in 50.1f..70f -&gt; Color(0xFF4CAF50) // Green for ideal&#10;                    else -&gt; Color(0xFF2196F3) // Blue for high humidity&#10;                }&#10;            }&#10;&#10;            // Función para mostrar el valor o N/A si no hay datos válidos&#10;            fun formatSensorValue(value: Float?, unit: String): String {&#10;                return if (value == null || value == -1.0f) &quot;N/A&quot; else &quot;${String.format(&quot;%.1f&quot;, value)}$unit&quot;&#10;            }&#10;&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Icono de Temperatura&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.ic_temperatura),&#10;                        contentDescription = &quot;DHT22 Temperature&quot;,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp)) // Spacer between icon and text&#10;                    Text(&#10;                        text = formatSensorValue(tempDHT, &quot;°C&quot;),&#10;                        style = MaterialTheme.typography.bodyLarge, // Changed to bodyLarge for better visibility&#10;                        color = getTemperatureColor(tempDHT), // Dynamic color for text&#10;                        fontWeight = FontWeight.Bold // Make sensor readings bold&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.height(4.dp)) // Small space between temperature and humidity readings&#10;&#10;                // Humidity Reading&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Icono de Humedad&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.ic_humedad),&#10;                        contentDescription = &quot;DHT22 Humidity&quot;,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp)) // Spacer between icon and text&#10;                    Text(&#10;                        text = formatSensorValue(humDHT, &quot;%&quot;),&#10;                        style = MaterialTheme.typography.bodyLarge, // Changed to bodyLarge for better visibility&#10;                        color = getHumidityColor(humDHT), // Dynamic color for text&#10;                        fontWeight = FontWeight.Bold // Make sensor readings bold&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;                .padding(16.dp)&#10;        ) {&#10;            TerrariumCard(terrarium = sampleTerrariumSmallNormal, onClick = { terrariumId -&gt;&#10;                println(&quot;Normal terrarium clicked: $terrariumId&quot;)&#10;            })&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            TerrariumCard(terrarium = sampleTerrariumSmallHighTemp, onClick = { terrariumId -&gt;&#10;                println(&quot;Hot terrarium clicked: $terrariumId&quot;)&#10;            })&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            TerrariumCard(terrarium = sampleTerrariumSmallLowTemp, onClick = { terrariumId -&gt;&#10;                println(&quot;Cold terrarium clicked: $terrariumId&quot;)&#10;            })&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            TerrariumCard(terrarium = sampleTerrariumSmallNoData, onClick = { terrariumId -&gt;&#10;                println(&quot;Empty terrarium clicked: $terrariumId&quot;)&#10;            })&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.components&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview // Important for @Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import com.waldoz_x.reptitrack.R // Ensure R is available for drawables&#10;&#10;// Composable to display a compact visual card of a terrarium.&#10;// Composable para mostrar una tarjeta visual compacta de un terrario.&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TerrariumCard(&#10;    terrarium: Terrarium,&#10;    modifier: Modifier = Modifier,&#10;    onClick: (String) -&gt; Unit // Callback for when the card is clicked&#10;) {&#10;    val cardBackgroundColor = Color.Black.copy(alpha = 0.7f) // Adjusted alpha for more darkness&#10;&#10;    Card(&#10;        modifier = modifier&#10;            .width(180.dp) // Fixed width for two columns layout&#10;            .padding(8.dp) // Reduced outer padding&#10;            .clickable { onClick(terrarium.id) }, // Makes the card clickable&#10;        elevation = CardDefaults.cardElevation(4.dp),&#10;        shape = RoundedCornerShape(16.dp), // Rounded corners&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = cardBackgroundColor // Fixed dark transparent background&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 8.dp, vertical = 12.dp), // Adjusted horizontal padding to give more space&#10;            horizontalAlignment = Alignment.CenterHorizontally // Centers content horizontally&#10;        ) {&#10;            // Terrarium image&#10;            // Imagen del terrario&#10;            Image(&#10;                painter = painterResource(id = terrarium.imageResId ?: R.drawable.terrario),&#10;                contentDescription = &quot;Imagen del terrario ${terrarium.name}&quot;,&#10;                modifier = Modifier&#10;                    .size(80.dp)&#10;                    .clip(RoundedCornerShape(8.dp)), // Elimina el background oscuro&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Terrarium name - fixed color (e.g., white or light gray)&#10;            // Nombre del terrario - color fijo (ej. blanco o gris claro)&#10;            Text(&#10;                text = terrarium.name,&#10;                style = MaterialTheme.typography.titleMedium, // Medium title size&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White, // Fixed white color for the name&#10;                maxLines = 1, // Limit to one line for small cards&#10;                overflow = TextOverflow.Ellipsis // Add ellipsis if text is too long&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            // DHT22 readings (Temperature and Humidity)&#10;            // Lecturas del DHT22 (Temperatura y Humedad)&#10;            val tempDHT = terrarium.dht22_1_temperature&#10;            val humDHT = terrarium.dht22_1_humidity&#10;&#10;            // Function to get color based on temperature&#10;            // Función para obtener el color basado en la temperatura&#10;            fun getTemperatureColor(temp: Float?): Color {&#10;                return when (temp) {&#10;                    null -&gt; Color.Gray // N/A color&#10;                    in 0f..17f -&gt; Color(0xFF2196F3) // Blue for very cold&#10;                    in 17.1f..22f -&gt; Color(0xFF03A9F4) // Lighter blue for cold&#10;                    in 22.1f..27f -&gt; Color(0xFF8BC34A) // Green for ideal/normal&#10;                    in 27.1f..32f -&gt; Color(0xFFFFC107) // Orange for warm&#10;                    else -&gt; Color(0xFFF44336) // Red for hot&#10;                }&#10;            }&#10;&#10;            // Function to get color based on humidity&#10;            // Función para obtener el color basado en la humedad&#10;            fun getHumidityColor(humidity: Float?): Color {&#10;                return when (humidity) {&#10;                    null -&gt; Color.Gray // N/A color&#10;                    in 0f..30f -&gt; Color(0xFFEF5350) // Red for very dry&#10;                    in 30.1f..50f -&gt; Color(0xFFFF9800) // Orange for dry&#10;                    in 50.1f..70f -&gt; Color(0xFF4CAF50) // Green for ideal&#10;                    else -&gt; Color(0xFF2196F3) // Blue for high humidity&#10;                }&#10;            }&#10;&#10;            // Función para mostrar el valor o N/A si no hay datos válidos&#10;            fun formatSensorValue(value: Float?, unit: String): String {&#10;                return if (value == null || value == -1.0f) &quot;N/A&quot; else &quot;${String.format(&quot;%.1f&quot;, value)}$unit&quot;&#10;            }&#10;&#10;            // Función para mostrar el valor o N/A si no hay datos válidos (DS18B20 usa -127.0 como error)&#10;            fun formatDs18b20Value(value: Float?): String {&#10;                return if (value == null || value == -127.0f) &quot;N/A&quot; else &quot;${String.format(&quot;%.1f&quot;, value)}°C&quot;&#10;            }&#10;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                // Temperature Reading&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Icono de Temperatura&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.ic_temperatura),&#10;                        contentDescription = &quot;DHT22 Temperature&quot;,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp)) // Spacer between icon and text&#10;                    Text(&#10;                        text = formatSensorValue(tempDHT, &quot;°C&quot;),&#10;                        style = MaterialTheme.typography.bodyLarge, // Changed to bodyLarge for better visibility&#10;                        color = getTemperatureColor(tempDHT), // Dynamic color for text&#10;                        fontWeight = FontWeight.Bold // Make sensor readings bold&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.height(4.dp)) // Small space between temperature and humidity readings&#10;&#10;                // Humidity Reading&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    // Icono de Humedad&#10;                    Icon(&#10;                        painter = painterResource(id = R.drawable.ic_humedad),&#10;                        contentDescription = &quot;DHT22 Humidity&quot;,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp)) // Spacer between icon and text&#10;                    Text(&#10;                        text = formatSensorValue(humDHT, &quot;%&quot;),&#10;                        style = MaterialTheme.typography.bodyLarge, // Changed to bodyLarge for better visibility&#10;                        color = getHumidityColor(humDHT), // Dynamic color for text&#10;                        fontWeight = FontWeight.Bold // Make sensor readings bold&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Lecturas DS18B20 (5 sensores)&#10;                Text(&#10;                    text = &quot;DS18B20&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = Color.White.copy(alpha = 0.7f),&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Spacer(modifier = Modifier.height(2.dp))&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = formatDs18b20Value(terrarium.ds18b20_1_temperature),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.White,&#10;                        modifier = Modifier.weight(1f),&#10;                        maxLines = 1&#10;                    )&#10;                    Text(&#10;                        text = formatDs18b20Value(terrarium.ds18b20_2_temperature),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.White,&#10;                        modifier = Modifier.weight(1f),&#10;                        maxLines = 1&#10;                    )&#10;                    Text(&#10;                        text = formatDs18b20Value(terrarium.ds18b20_3_temperature),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.White,&#10;                        modifier = Modifier.weight(1f),&#10;                        maxLines = 1&#10;                    )&#10;                    Text(&#10;                        text = formatDs18b20Value(terrarium.ds18b20_4_temperature),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.White,&#10;                        modifier = Modifier.weight(1f),&#10;                        maxLines = 1&#10;                    )&#10;                    Text(&#10;                        text = formatDs18b20Value(terrarium.ds18b20_5_temperature),&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.White,&#10;                        modifier = Modifier.weight(1f),&#10;                        maxLines = 1&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;// --- PREVIEW SECTION ---&#10;// Sección de previsualización&#10;@Preview(showBackground = true, name = &quot;Small Terrarium Card&quot;)&#10;@Composable&#10;fun PreviewSmallTerrariumCard() {&#10;    // Example data for the small card preview&#10;    // Datos de ejemplo para la previsualización de la tarjeta pequeña&#10;    val sampleTerrariumSmallNormal = Terrarium(&#10;        id = &quot;ter_small_001&quot;,&#10;        name = &quot;Iguana Terrarium&quot;, // Changed name for example&#10;        description = &quot;Un terrario de ejemplo para previsualización.&quot;,&#10;        imageResId = R.drawable.terrario,&#10;        dht22_1_temperature = 25.0f, // Normal temp (green)&#10;        dht22_1_humidity = 60.5f // Normal humidity (green)&#10;    )&#10;&#10;    val sampleTerrariumSmallHighTemp = Terrarium(&#10;        id = &quot;ter_small_003&quot;,&#10;        name = &quot;Gecko Hotbox&quot;, // Changed name for example&#10;        description = &quot;Terrarium with high temperature.&quot;,&#10;        imageResId = R.drawable.terrario, // Use the terrario image&#10;        dht22_1_temperature = 35.5f, // High temp (red)&#10;        dht22_1_humidity = 40.0f // Dry humidity (orange)&#10;    )&#10;&#10;    val sampleTerrariumSmallLowTemp = Terrarium(&#10;        id = &quot;ter_small_004&quot;,&#10;        name = &quot;Chameleon Den&quot;, // Changed name for example&#10;        description = &quot;Terrarium with low temperature.&quot;,&#10;        imageResId = R.drawable.terrario, // Use the terrario image&#10;        dht22_1_temperature = 15.0f, // Low temp (blue)&#10;        dht22_1_humidity = 80.0f // High humidity (blue)&#10;    )&#10;&#10;    val sampleTerrariumSmallNoData = Terrarium(&#10;        id = &quot;ter_small_002&quot;,&#10;        name = &quot;Empty Enclosure&quot;, // Changed name for example&#10;        description = &quot;Terrarium with no sensor data.&quot;,&#10;        imageResId = R.drawable.terrario, // Use the terrario image&#10;        dht22_1_temperature = null,&#10;        dht22_1_humidity = null&#10;    )&#10;&#10;    MaterialTheme {&#10;        // Set a dark background for the preview to better visualize transparency&#10;        // Establece un fondo oscuro para la previsualización para visualizar mejor la transparencia&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(Color.DarkGray) // Simulate your dark background&#10;                .padding(16.dp)&#10;        ) {&#10;            TerrariumCard(terrarium = sampleTerrariumSmallNormal, onClick = { terrariumId -&gt;&#10;                println(&quot;Normal terrarium clicked: $terrariumId&quot;)&#10;            })&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            TerrariumCard(terrarium = sampleTerrariumSmallHighTemp, onClick = { terrariumId -&gt;&#10;                println(&quot;Hot terrarium clicked: $terrariumId&quot;)&#10;            })&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            TerrariumCard(terrarium = sampleTerrariumSmallLowTemp, onClick = { terrariumId -&gt;&#10;                println(&quot;Cold terrarium clicked: $terrariumId&quot;)&#10;            })&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            TerrariumCard(terrarium = sampleTerrariumSmallNoData, onClick = { terrariumId -&gt;&#10;                println(&quot;Empty terrarium clicked: $terrariumId&quot;)&#10;            })&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/sensorUtils/SensorIcons.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/sensorUtils/SensorIcons.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.components.sensorUtils&#10;&#10;import com.waldoz_x.reptitrack.R&#10;&#10;fun getSensorIcon(sensorType: String): Int {&#10;    return when (sensorType.lowercase()) {&#10;        &quot;temperatura&quot;, &quot;temperature&quot; -&gt; R.drawable.ic_temperatura&#10;        &quot;humedad&quot;, &quot;humidity&quot; -&gt; R.drawable.ic_humedad&#10;        else -&gt; R.drawable.ic_baseline_info_24 // Usa un ícono genérico si tienes uno, si no, usa uno existente&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.components.sensorUtils&#10;&#10;import com.waldoz_x.reptitrack.R&#10;&#10;// Elimina la función getSensorIcon de este archivo para evitar duplicidad.&#10;// ...existing code..." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/sensorUtils/getSensorIcon.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/components/sensorUtils/getSensorIcon.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.components.sensorUtils&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.components.sensorUtils&#10;&#10;import com.waldoz_x.reptitrack.R&#10;&#10;fun getSensorIcon(sensorType: String): Int {&#10;    return when (sensorType.lowercase()) {&#10;        &quot;temperature&quot;, &quot;temperatura&quot; -&gt; R.drawable.ic_temperatura&#10;        &quot;humidity&quot;, &quot;humedad&quot; -&gt; R.drawable.ic_humedad&#10;        &quot;distance&quot;, &quot;distancia&quot; -&gt; R.drawable.ic_distance // Usa el ícono que tengas para distancia&#10;        &quot;power&quot;, &quot;potencia&quot; -&gt; R.drawable.ic_power // Usa el ícono que tengas para potencia&#10;        else -&gt; R.drawable.ic_sensor // Ícono genérico o uno por defecto&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/screens/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/screens/home/HomeViewModel.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.screens.home&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth // Importa FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore // Importa FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue // Importa FieldValue para timestamps&#10;import com.waldoz_x.reptitrack.data.source.remote.HiveMqttClient&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import com.waldoz_x.reptitrack.domain.usecase.GetAllTerrariumsUseCase&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.catch // Importa catch&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await // Para usar await en tareas de Firebase&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val getAllTerrariumsUseCase: GetAllTerrariumsUseCase,&#10;    private val hiveMqttClient: HiveMqttClient,&#10;    private val auth: FirebaseAuth, // Inyecta FirebaseAuth&#10;    private val firestore: FirebaseFirestore // Inyecta FirebaseFirestore&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow&lt;HomeUiState&gt;(HomeUiState.Loading)&#10;    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState&#10;&#10;    val mqttConnectionState: StateFlow&lt;Boolean&gt; = hiveMqttClient.isConnected&#10;    val mqttReceivedMessages: StateFlow&lt;Pair&lt;String, String&gt;?&gt; = hiveMqttClient.receivedMessages&#10;&#10;    private val _firebaseConnectionState = MutableStateFlow(false) // Estado de conexión de Firebase&#10;    val firebaseConnectionState: StateFlow&lt;Boolean&gt; = _firebaseConnectionState&#10;&#10;    private val _currentUserData = MutableStateFlow&lt;UserData?&gt;(null) // Datos del usuario actual&#10;    val currentUserData: StateFlow&lt;UserData?&gt; = _currentUserData&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            // 1. Manejar autenticación de Firebase&#10;            // Este listener se activa cada vez que el estado de autenticación de Firebase cambia.&#10;            auth.addAuthStateListener { firebaseAuth -&gt;&#10;                val user = firebaseAuth.currentUser&#10;                if (user != null) {&#10;                    // Usuario autenticado (registrado o anónimo)&#10;                    val userId = user.uid&#10;                    Log.d(&quot;HomeViewModel&quot;, &quot;Usuario autenticado: $userId&quot;)&#10;                    // Cargar datos del usuario y actualizar el último inicio de sesión&#10;                    updateUserLoginStatus(userId, user.isAnonymous, user.email)&#10;                    // Carga terrarios para el usuario actual. Es crucial que esto se llame después de tener el userId.&#10;                    loadTerrariums(userId)&#10;                    // SUSCRIBIRSE AL TOPIC DE SENSORES MQTT CORRECTO&#10;                    val topic = &quot;reptritrack/${userId}/#&quot;&#10;                    hiveMqttClient.subscribeToTopic(topic)&#10;                } else {&#10;                    // No hay usuario, intentar iniciar sesión anónimamente.&#10;                    // Esto ocurre en el primer inicio de la app o si el usuario cierra sesión.&#10;                    Log.d(&quot;HomeViewModel&quot;, &quot;No hay usuario, intentando iniciar sesión anónimamente...&quot;)&#10;                    signInAnonymously()&#10;                }&#10;            }&#10;&#10;            // 2. Conectar MQTT&#10;            // La conexión MQTT se inicia independientemente de la autenticación de Firebase.&#10;            hiveMqttClient.connect()&#10;            // (Ya no es necesario suscribirse a terrariums/data/# aquí)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Intenta iniciar sesión en Firebase de forma anónima.&#10;     * Si tiene éxito, actualiza el estado del usuario en Firestore y carga los terrarios.&#10;     */&#10;    private fun signInAnonymously() = viewModelScope.launch {&#10;        try {&#10;            val result = auth.signInAnonymously().await()&#10;            val user = result.user&#10;            if (user != null) {&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Sesión anónima iniciada con UID: ${user.uid}&quot;)&#10;                // Crear/actualizar el documento del usuario en Firestore para el usuario anónimo&#10;                updateUserLoginStatus(user.uid, true, null)&#10;                loadTerrariums(user.uid) // Carga terrarios para el nuevo usuario anónimo&#10;            } else {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Error: Usuario anónimo nulo después del inicio de sesión.&quot;)&#10;                _firebaseConnectionState.value = false&#10;                _uiState.value = HomeUiState.Error(&quot;No se pudo iniciar sesión anónimamente.&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;HomeViewModel&quot;, &quot;Error al iniciar sesión anónimamente: ${e.message}&quot;, e)&#10;            _firebaseConnectionState.value = false&#10;            _uiState.value = HomeUiState.Error(&quot;Error de autenticación: ${e.localizedMessage ?: &quot;Desconocido&quot;}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza el documento del usuario en Firestore con su estado de sesión (invitado, email)&#10;     * y la marca de tiempo del último inicio de sesión.&#10;     * También escucha los cambios en el documento del usuario para mantener `currentUserData` actualizado.&#10;     * @param userId El ID del usuario actual.&#10;     * @param isAnonymous Indica si el usuario es anónimo.&#10;     * @param email El correo electrónico del usuario, si está registrado.&#10;     */&#10;    private fun updateUserLoginStatus(userId: String, isAnonymous: Boolean, email: String?) = viewModelScope.launch {&#10;        try {&#10;            val userDocRef = firestore.collection(&quot;usuarios&quot;).document(userId)&#10;            val userData = hashMapOf(&#10;                &quot;isGuest&quot; to isAnonymous,&#10;                &quot;email&quot; to email,&#10;                &quot;ultimoInicioSesion&quot; to FieldValue.serverTimestamp() // Usa un timestamp del servidor para mayor precisión&#10;            )&#10;            // Usa SetOptions.merge() para no sobrescribir otros campos existentes (como 'nombre')&#10;            userDocRef.set(userData, com.google.firebase.firestore.SetOptions.merge()).await()&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Estado de usuario y último inicio de sesión actualizados para $userId&quot;)&#10;&#10;            // Escucha en tiempo real los datos del usuario para la UI&#10;            userDocRef.addSnapshotListener { snapshot, e -&gt;&#10;                if (e != null) {&#10;                    Log.e(&quot;HomeViewModel&quot;, &quot;Error al escuchar datos del usuario: ${e.message}&quot;, e)&#10;                    _currentUserData.value = null&#10;                    return@addSnapshotListener&#10;                }&#10;                if (snapshot != null &amp;&amp; snapshot.exists()) {&#10;                    val data = snapshot.data&#10;                    _currentUserData.value = UserData(&#10;                        id = userId,&#10;                        name = data?.get(&quot;nombre&quot;) as? String, // Asume que 'nombre' podría existir si el usuario se registra&#10;                        isGuest = data?.get(&quot;isGuest&quot;) as? Boolean ?: isAnonymous, // Prioriza el dato de Firestore, si no, usa el de Auth&#10;                        email = data?.get(&quot;email&quot;) as? String ?: email, // Prioriza el dato de Firestore, si no, usa el de Auth&#10;                        lastLogin = data?.get(&quot;ultimoInicioSesion&quot;) as? com.google.firebase.firestore.ServerTimestamp&#10;                    )&#10;                } else {&#10;                    _currentUserData.value = null&#10;                }&#10;            }&#10;            _firebaseConnectionState.value = true // Si la actualización inicial es exitosa, Firebase está conectado&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;HomeViewModel&quot;, &quot;Error al actualizar el estado de login del usuario: ${e.message}&quot;, e)&#10;            _firebaseConnectionState.value = false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga los terrarios para el usuario actual.&#10;     * Si no se proporciona un userId, intenta obtenerlo del usuario autenticado actualmente.&#10;     * @param userId El ID del usuario para el que se cargarán los terrarios (opcional).&#10;     */&#10;    fun loadTerrariums(userId: String? = auth.currentUser?.uid) {&#10;        if (userId == null) {&#10;            Log.w(&quot;HomeViewModel&quot;, &quot;No hay userId disponible para cargar terrarios.&quot;)&#10;            _uiState.value = HomeUiState.Error(&quot;No hay usuario autenticado para cargar terrarios.&quot;)&#10;            _firebaseConnectionState.value = false&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = HomeUiState.Loading&#10;            try {&#10;                // Pasa el userId al caso de uso GetAllTerrariumsUseCase&#10;                getAllTerrariumsUseCase(userId)&#10;                    .catch { e -&gt;&#10;                        // Captura errores del flujo de datos de terrarios&#10;                        Log.e(&quot;HomeViewModel&quot;, &quot;Error al cargar terrarios para $userId: ${e.message}&quot;, e)&#10;                        _uiState.value = HomeUiState.Error(e.localizedMessage ?: &quot;Error desconocido al cargar terrarios&quot;)&#10;                        _firebaseConnectionState.value = false&#10;                    }&#10;                    .collectLatest { terrariums -&gt;&#10;                        _uiState.value = HomeUiState.Success(terrariums)&#10;                        _firebaseConnectionState.value = true // Si la carga es exitosa, Firebase está conectado&#10;                    }&#10;            } catch (e: Exception) {&#10;                // Captura errores generales de la corrutina (ej. problemas de red antes de que el flujo se establezca)&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Excepción al cargar terrarios para $userId: ${e.message}&quot;, e)&#10;                _uiState.value = HomeUiState.Error(e.localizedMessage ?: &quot;Error desconocido al cargar terrarios&quot;)&#10;                _firebaseConnectionState.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publica un mensaje MQTT en un tópico específico.&#10;     * @param topic El tópico MQTT.&#10;     * @param message El mensaje a publicar.&#10;     */&#10;    fun publishMqttCommand(topic: String, message: String) {&#10;        viewModelScope.launch {&#10;            hiveMqttClient.publishMessage(topic, message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Se llama cuando el ViewModel ya no está en uso y será destruido.&#10;     * Se usa para desconectar el cliente MQTT y liberar recursos.&#10;     */&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        viewModelScope.launch {&#10;            hiveMqttClient.disconnect()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Crea un nuevo terrario en Firestore con la estructura predefinida.&#10;     * @param newTerrariumName El nombre del nuevo terrario.&#10;     */&#10;    fun createTerrarium(newTerrariumName: String) {&#10;        val userId = auth.currentUser?.uid&#10;        if (userId == null) {&#10;            _uiState.value = HomeUiState.Error(&quot;No hay usuario autenticado para crear terrarios.&quot;)&#10;            return&#10;        }&#10;        viewModelScope.launch {&#10;            try {&#10;                // Genera el ID del documento de terrario correctamente&#10;                val terrariumsCollection = firestore.collection(&quot;usuarios&quot;)&#10;                    .document(userId)&#10;                    .collection(&quot;terrarios&quot;)&#10;                val terrariumDocRef = terrariumsCollection.document() // Esto genera un nuevo ID válido&#10;                val terrariumId = terrariumDocRef.id&#10;&#10;                val terrariumData = hashMapOf(&#10;                    &quot;id&quot; to terrariumId, // &lt;-- Guarda el ID generado en el documento&#10;                    &quot;nombre&quot; to newTerrariumName,&#10;                    &quot;dispositivos&quot; to hashMapOf&lt;String, Any&gt;(&#10;                        &quot;esp01&quot; to hashMapOf(&#10;                            &quot;sensores&quot; to hashMapOf(&#10;                                &quot;pzem_01&quot; to hashMapOf(&#10;                                    &quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()&#10;                                )&#10;                            ),&#10;                            &quot;actuadores&quot; to hashMapOf(&#10;                                &quot;dispensador&quot; to hashMapOf(&#10;                                    &quot;programacion&quot; to hashMapOf(&#10;                                        &quot;compartimientos&quot; to hashMapOf(&#10;                                            &quot;comp_01&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            ),&#10;                                            &quot;comp_02&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            ),&#10;                                            &quot;comp_03&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            ),&#10;                                            &quot;comp_04&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            ),&#10;                                            &quot;comp_05&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            )&#10;                                        )&#10;                                    )&#10;                                )&#10;                            )&#10;                        ),&#10;                        &quot;esp02&quot; to hashMapOf(&#10;                            &quot;sensores&quot; to hashMapOf(&#10;                                &quot;dht_01&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;dht_02&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;dht_03&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;dht_04&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;ds18b20_01&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;ds18b20_02&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;ds18b20_03&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;ds18b20_04&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;())&#10;                            ),&#10;                            &quot;actuadores&quot; to hashMapOf(&#10;                                &quot;bomba&quot; to hashMapOf(&#10;                                    &quot;activo&quot; to false,&#10;                                    &quot;manual&quot; to false,&#10;                                    &quot;programacion&quot; to hashMapOf(&#10;                                        &quot;evento_001&quot; to hashMapOf(&#10;                                            &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                            &quot;activado&quot; to false,&#10;                                            &quot;manual&quot; to false,&#10;                                            &quot;duracion_segundos&quot; to 30&#10;                                        ),&#10;                                        &quot;evento_002&quot; to hashMapOf(&#10;                                            &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                            &quot;activado&quot; to false,&#10;                                            &quot;manual&quot; to false,&#10;                                            &quot;duracion_segundos&quot; to 45&#10;                                        )&#10;                                    )&#10;                                ),&#10;                                &quot;focos&quot; to hashMapOf(&#10;                                    &quot;activo&quot; to false,&#10;                                    &quot;manual&quot; to false,&#10;                                    &quot;programacion&quot; to hashMapOf(&#10;                                        &quot;foco_001&quot; to hashMapOf(&#10;                                            &quot;fecha_encendido&quot; to &quot;&quot;,&#10;                                            &quot;fecha_apagado&quot; to &quot;&quot;,&#10;                                            &quot;encendido&quot; to false,&#10;                                            &quot;manual&quot; to false&#10;                                        ),&#10;                                        &quot;foco_002&quot; to hashMapOf(&#10;                                            &quot;fecha_encendido&quot; to &quot;&quot;,&#10;                                            &quot;fecha_apagado&quot; to &quot;&quot;,&#10;                                            &quot;encendido&quot; to false,&#10;                                            &quot;manual&quot; to false&#10;                                        )&#10;                                    )&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                // Guarda el terrario en la ruta correcta: usuarios/{userId}/terrarios/{terrariumId}&#10;                terrariumDocRef.set(terrariumData).await()&#10;&#10;                // Recarga la lista de terrarios después de crear uno nuevo&#10;                loadTerrariums(userId)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Error al crear terrario: ${e.message}&quot;, e)&#10;                _uiState.value = HomeUiState.Error(&quot;No se pudo crear el terrario: ${e.localizedMessage ?: &quot;Error desconocido&quot;}&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Mantén aquí la definición de HomeUiState y UserData.&#10;sealed class HomeUiState {&#10;    object Loading : HomeUiState()&#10;    data class Success(val terrariums: List&lt;Terrarium&gt;) : HomeUiState()&#10;    data class Error(val message: String) : HomeUiState()&#10;}&#10;&#10;/**&#10; * Clase de datos para representar la información relevante del usuario para la UI.&#10; * @param id El UID del usuario.&#10; * @param name El nombre del usuario (opcional).&#10; * @param isGuest Verdadero si el usuario es anónimo, falso si está registrado.&#10; * @param email El correo electrónico del usuario (opcional, solo si está registrado).&#10; * @param lastLogin La marca de tiempo del último inicio de sesión.&#10; */&#10;data class UserData(&#10;    val id: String,&#10;    val name: String?,&#10;    val isGuest: Boolean,&#10;    val email: String?,&#10;    val lastLogin: com.google.firebase.firestore.ServerTimestamp?&#10;)&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.screens.home&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth // Importa FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore // Importa FirebaseFirestore&#10;import com.google.firebase.firestore.FieldValue // Importa FieldValue para timestamps&#10;import com.waldoz_x.reptitrack.data.source.remote.HiveMqttClient&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import com.waldoz_x.reptitrack.domain.usecase.GetAllTerrariumsUseCase&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.catch // Importa catch&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await // Para usar await en tareas de Firebase&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val getAllTerrariumsUseCase: GetAllTerrariumsUseCase,&#10;    private val hiveMqttClient: HiveMqttClient,&#10;    private val auth: FirebaseAuth, // Inyecta FirebaseAuth&#10;    private val firestore: FirebaseFirestore // Inyecta FirebaseFirestore&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow&lt;HomeUiState&gt;(HomeUiState.Loading)&#10;    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState&#10;&#10;    val mqttConnectionState: StateFlow&lt;Boolean&gt; = hiveMqttClient.isConnected&#10;    val mqttReceivedMessages: StateFlow&lt;Pair&lt;String, String&gt;?&gt; = hiveMqttClient.receivedMessages&#10;&#10;    private val _firebaseConnectionState = MutableStateFlow(false) // Estado de conexión de Firebase&#10;    val firebaseConnectionState: StateFlow&lt;Boolean&gt; = _firebaseConnectionState&#10;&#10;    private val _currentUserData = MutableStateFlow&lt;UserData?&gt;(null) // Datos del usuario actual&#10;    val currentUserData: StateFlow&lt;UserData?&gt; = _currentUserData&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            // 1. Manejar autenticación de Firebase&#10;            // Este listener se activa cada vez que el estado de autenticación de Firebase cambia.&#10;            auth.addAuthStateListener { firebaseAuth -&gt;&#10;                val user = firebaseAuth.currentUser&#10;                if (user != null) {&#10;                    // Usuario autenticado (registrado o anónimo)&#10;                    val userId = user.uid&#10;                    Log.d(&quot;HomeViewModel&quot;, &quot;Usuario autenticado: $userId&quot;)&#10;                    // Cargar datos del usuario y actualizar el último inicio de sesión&#10;                    updateUserLoginStatus(userId, user.isAnonymous, user.email)&#10;                    // Carga terrarios para el usuario actual. Es crucial que esto se llame después de tener el userId.&#10;                    loadTerrariums(userId)&#10;                    // SUSCRIBIRSE AL TOPIC DE SENSORES MQTT CORRECTO&#10;                    val topic = &quot;reptritrack/${userId}/#&quot;&#10;                    viewModelScope.launch {&#10;                        hiveMqttClient.subscribeToTopic(topic)&#10;                    }&#10;                } else {&#10;                    // No hay usuario, intentar iniciar sesión anónimamente.&#10;                    // Esto ocurre en el primer inicio de la app o si el usuario cierra sesión.&#10;                    Log.d(&quot;HomeViewModel&quot;, &quot;No hay usuario, intentando iniciar sesión anónimamente...&quot;)&#10;                    signInAnonymously()&#10;                }&#10;            }&#10;&#10;            // 2. Conectar MQTT&#10;            // La conexión MQTT se inicia independientemente de la autenticación de Firebase.&#10;            hiveMqttClient.connect()&#10;            // (Ya no es necesario suscribirse a terrariums/data/# aquí)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Intenta iniciar sesión en Firebase de forma anónima.&#10;     * Si tiene éxito, actualiza el estado del usuario en Firestore y carga los terrarios.&#10;     */&#10;    private fun signInAnonymously() = viewModelScope.launch {&#10;        try {&#10;            val result = auth.signInAnonymously().await()&#10;            val user = result.user&#10;            if (user != null) {&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Sesión anónima iniciada con UID: ${user.uid}&quot;)&#10;                // Crear/actualizar el documento del usuario en Firestore para el usuario anónimo&#10;                updateUserLoginStatus(user.uid, true, null)&#10;                loadTerrariums(user.uid) // Carga terrarios para el nuevo usuario anónimo&#10;            } else {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Error: Usuario anónimo nulo después del inicio de sesión.&quot;)&#10;                _firebaseConnectionState.value = false&#10;                _uiState.value = HomeUiState.Error(&quot;No se pudo iniciar sesión anónimamente.&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;HomeViewModel&quot;, &quot;Error al iniciar sesión anónimamente: ${e.message}&quot;, e)&#10;            _firebaseConnectionState.value = false&#10;            _uiState.value = HomeUiState.Error(&quot;Error de autenticación: ${e.localizedMessage ?: &quot;Desconocido&quot;}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza el documento del usuario en Firestore con su estado de sesión (invitado, email)&#10;     * y la marca de tiempo del último inicio de sesión.&#10;     * También escucha los cambios en el documento del usuario para mantener `currentUserData` actualizado.&#10;     * @param userId El ID del usuario actual.&#10;     * @param isAnonymous Indica si el usuario es anónimo.&#10;     * @param email El correo electrónico del usuario, si está registrado.&#10;     */&#10;    private fun updateUserLoginStatus(userId: String, isAnonymous: Boolean, email: String?) = viewModelScope.launch {&#10;        try {&#10;            val userDocRef = firestore.collection(&quot;usuarios&quot;).document(userId)&#10;            val userData = hashMapOf(&#10;                &quot;isGuest&quot; to isAnonymous,&#10;                &quot;email&quot; to email,&#10;                &quot;ultimoInicioSesion&quot; to FieldValue.serverTimestamp() // Usa un timestamp del servidor para mayor precisión&#10;            )&#10;            // Usa SetOptions.merge() para no sobrescribir otros campos existentes (como 'nombre')&#10;            userDocRef.set(userData, com.google.firebase.firestore.SetOptions.merge()).await()&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Estado de usuario y último inicio de sesión actualizados para $userId&quot;)&#10;&#10;            // Escucha en tiempo real los datos del usuario para la UI&#10;            userDocRef.addSnapshotListener { snapshot, e -&gt;&#10;                if (e != null) {&#10;                    Log.e(&quot;HomeViewModel&quot;, &quot;Error al escuchar datos del usuario: ${e.message}&quot;, e)&#10;                    _currentUserData.value = null&#10;                    return@addSnapshotListener&#10;                }&#10;                if (snapshot != null &amp;&amp; snapshot.exists()) {&#10;                    val data = snapshot.data&#10;                    _currentUserData.value = UserData(&#10;                        id = userId,&#10;                        name = data?.get(&quot;nombre&quot;) as? String, // Asume que 'nombre' podría existir si el usuario se registra&#10;                        isGuest = data?.get(&quot;isGuest&quot;) as? Boolean ?: isAnonymous, // Prioriza el dato de Firestore, si no, usa el de Auth&#10;                        email = data?.get(&quot;email&quot;) as? String ?: email, // Prioriza el dato de Firestore, si no, usa el de Auth&#10;                        lastLogin = data?.get(&quot;ultimoInicioSesion&quot;) as? com.google.firebase.firestore.ServerTimestamp&#10;                    )&#10;                } else {&#10;                    _currentUserData.value = null&#10;                }&#10;            }&#10;            _firebaseConnectionState.value = true // Si la actualización inicial es exitosa, Firebase está conectado&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;HomeViewModel&quot;, &quot;Error al actualizar el estado de login del usuario: ${e.message}&quot;, e)&#10;            _firebaseConnectionState.value = false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga los terrarios para el usuario actual.&#10;     * Si no se proporciona un userId, intenta obtenerlo del usuario autenticado actualmente.&#10;     * @param userId El ID del usuario para el que se cargarán los terrarios (opcional).&#10;     */&#10;    fun loadTerrariums(userId: String? = auth.currentUser?.uid) {&#10;        if (userId == null) {&#10;            Log.w(&quot;HomeViewModel&quot;, &quot;No hay userId disponible para cargar terrarios.&quot;)&#10;            _uiState.value = HomeUiState.Error(&quot;No hay usuario autenticado para cargar terrarios.&quot;)&#10;            _firebaseConnectionState.value = false&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = HomeUiState.Loading&#10;            try {&#10;                // Pasa el userId al caso de uso GetAllTerrariumsUseCase&#10;                getAllTerrariumsUseCase(userId)&#10;                    .catch { e -&gt;&#10;                        // Captura errores del flujo de datos de terrarios&#10;                        Log.e(&quot;HomeViewModel&quot;, &quot;Error al cargar terrarios para $userId: ${e.message}&quot;, e)&#10;                        _uiState.value = HomeUiState.Error(e.localizedMessage ?: &quot;Error desconocido al cargar terrarios&quot;)&#10;                        _firebaseConnectionState.value = false&#10;                    }&#10;                    .collectLatest { terrariums -&gt;&#10;                        _uiState.value = HomeUiState.Success(terrariums)&#10;                        _firebaseConnectionState.value = true // Si la carga es exitosa, Firebase está conectado&#10;                    }&#10;            } catch (e: Exception) {&#10;                // Captura errores generales de la corrutina (ej. problemas de red antes de que el flujo se establezca)&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Excepción al cargar terrarios para $userId: ${e.message}&quot;, e)&#10;                _uiState.value = HomeUiState.Error(e.localizedMessage ?: &quot;Error desconocido al cargar terrarios&quot;)&#10;                _firebaseConnectionState.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publica un mensaje MQTT en un tópico específico.&#10;     * @param topic El tópico MQTT.&#10;     * @param message El mensaje a publicar.&#10;     */&#10;    fun publishMqttCommand(topic: String, message: String) {&#10;        viewModelScope.launch {&#10;            hiveMqttClient.publishMessage(topic, message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Se llama cuando el ViewModel ya no está en uso y será destruido.&#10;     * Se usa para desconectar el cliente MQTT y liberar recursos.&#10;     */&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        viewModelScope.launch {&#10;            hiveMqttClient.disconnect()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Crea un nuevo terrario en Firestore con la estructura predefinida.&#10;     * @param newTerrariumName El nombre del nuevo terrario.&#10;     */&#10;    fun createTerrarium(newTerrariumName: String) {&#10;        val userId = auth.currentUser?.uid&#10;        if (userId == null) {&#10;            _uiState.value = HomeUiState.Error(&quot;No hay usuario autenticado para crear terrarios.&quot;)&#10;            return&#10;        }&#10;        viewModelScope.launch {&#10;            try {&#10;                // Genera el ID del documento de terrario correctamente&#10;                val terrariumsCollection = firestore.collection(&quot;usuarios&quot;)&#10;                    .document(userId)&#10;                    .collection(&quot;terrarios&quot;)&#10;                val terrariumDocRef = terrariumsCollection.document() // Esto genera un nuevo ID válido&#10;                val terrariumId = terrariumDocRef.id&#10;&#10;                val terrariumData = hashMapOf(&#10;                    &quot;id&quot; to terrariumId, // &lt;-- Guarda el ID generado en el documento&#10;                    &quot;nombre&quot; to newTerrariumName,&#10;                    &quot;dispositivos&quot; to hashMapOf&lt;String, Any&gt;(&#10;                        &quot;esp01&quot; to hashMapOf(&#10;                            &quot;sensores&quot; to hashMapOf(&#10;                                &quot;pzem_01&quot; to hashMapOf(&#10;                                    &quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()&#10;                                )&#10;                            ),&#10;                            &quot;actuadores&quot; to hashMapOf(&#10;                                &quot;dispensador&quot; to hashMapOf(&#10;                                    &quot;programacion&quot; to hashMapOf(&#10;                                        &quot;compartimientos&quot; to hashMapOf(&#10;                                            &quot;comp_01&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            ),&#10;                                            &quot;comp_02&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            ),&#10;                                            &quot;comp_03&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            ),&#10;                                            &quot;comp_04&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            ),&#10;                                            &quot;comp_05&quot; to hashMapOf(&#10;                                                &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                                &quot;dispensado&quot; to false,&#10;                                                &quot;manual&quot; to false&#10;                                            )&#10;                                        )&#10;                                    )&#10;                                )&#10;                            )&#10;                        ),&#10;                        &quot;esp02&quot; to hashMapOf(&#10;                            &quot;sensores&quot; to hashMapOf(&#10;                                &quot;dht_01&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;dht_02&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;dht_03&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;dht_04&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;ds18b20_01&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;ds18b20_02&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;ds18b20_03&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;()),&#10;                                &quot;ds18b20_04&quot; to hashMapOf(&quot;lecturas&quot; to hashMapOf&lt;String, Any&gt;())&#10;                            ),&#10;                            &quot;actuadores&quot; to hashMapOf(&#10;                                &quot;bomba&quot; to hashMapOf(&#10;                                    &quot;activo&quot; to false,&#10;                                    &quot;manual&quot; to false,&#10;                                    &quot;programacion&quot; to hashMapOf(&#10;                                        &quot;evento_001&quot; to hashMapOf(&#10;                                            &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                            &quot;activado&quot; to false,&#10;                                            &quot;manual&quot; to false,&#10;                                            &quot;duracion_segundos&quot; to 30&#10;                                        ),&#10;                                        &quot;evento_002&quot; to hashMapOf(&#10;                                            &quot;fecha_programada&quot; to &quot;&quot;,&#10;                                            &quot;activado&quot; to false,&#10;                                            &quot;manual&quot; to false,&#10;                                            &quot;duracion_segundos&quot; to 45&#10;                                        )&#10;                                    )&#10;                                ),&#10;                                &quot;focos&quot; to hashMapOf(&#10;                                    &quot;activo&quot; to false,&#10;                                    &quot;manual&quot; to false,&#10;                                    &quot;programacion&quot; to hashMapOf(&#10;                                        &quot;foco_001&quot; to hashMapOf(&#10;                                            &quot;fecha_encendido&quot; to &quot;&quot;,&#10;                                            &quot;fecha_apagado&quot; to &quot;&quot;,&#10;                                            &quot;encendido&quot; to false,&#10;                                            &quot;manual&quot; to false&#10;                                        ),&#10;                                        &quot;foco_002&quot; to hashMapOf(&#10;                                            &quot;fecha_encendido&quot; to &quot;&quot;,&#10;                                            &quot;fecha_apagado&quot; to &quot;&quot;,&#10;                                            &quot;encendido&quot; to false,&#10;                                            &quot;manual&quot; to false&#10;                                        )&#10;                                    )&#10;                                )&#10;                            )&#10;                        )&#10;                    )&#10;                )&#10;&#10;                // Guarda el terrario en la ruta correcta: usuarios/{userId}/terrarios/{terrariumId}&#10;                terrariumDocRef.set(terrariumData).await()&#10;&#10;                // Recarga la lista de terrarios después de crear uno nuevo&#10;                loadTerrariums(userId)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Error al crear terrario: ${e.message}&quot;, e)&#10;                _uiState.value = HomeUiState.Error(&quot;No se pudo crear el terrario: ${e.localizedMessage ?: &quot;Error desconocido&quot;}&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Mantén aquí la definición de HomeUiState y UserData.&#10;sealed class HomeUiState {&#10;    object Loading : HomeUiState()&#10;    data class Success(val terrariums: List&lt;Terrarium&gt;) : HomeUiState()&#10;    data class Error(val message: String) : HomeUiState()&#10;}&#10;&#10;/**&#10; * Clase de datos para representar la información relevante del usuario para la UI.&#10; * @param id El UID del usuario.&#10; * @param name El nombre del usuario (opcional).&#10; * @param isGuest Verdadero si el usuario es anónimo, falso si está registrado.&#10; * @param email El correo electrónico del usuario (opcional, solo si está registrado).&#10; * @param lastLogin La marca de tiempo del último inicio de sesión.&#10; */&#10;data class UserData(&#10;    val id: String,&#10;    val name: String?,&#10;    val isGuest: Boolean,&#10;    val email: String?,&#10;    val lastLogin: com.google.firebase.firestore.ServerTimestamp?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/screens/settings/SettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/screens/settings/SettingsScreen.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.screens.settings&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.painter.Painter&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.waldoz_x.reptitrack.R&#10;import com.waldoz_x.reptitrack.ui.theme.ReptiTrackTheme&#10;import java.util.TimeZone&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SettingsScreen(&#10;    onBackClick: () -&gt; Unit,&#10;    navigateToTimeZoneSelection: () -&gt; Unit,&#10;    navigateToCountryRegionSelection: () -&gt; Unit,&#10;    navigateToMqttSettings: () -&gt; Unit,&#10;    // ¡NUEVO! Añade este parámetro para la navegación temporal al detalle del terrario&#10;    navigateToTerrariumDetailPlaceholder: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: SettingsViewModel = hiltViewModel()&#10;) {&#10;    val autoUpdateMobileData by viewModel.autoUpdateMobileData.collectAsState()&#10;    val autoUpdateWifi by viewModel.autoUpdateWifi.collectAsState()&#10;    val selectedTimeZoneId by viewModel.selectedTimeZoneId.collectAsState()&#10;    val selectedCountryRegion by viewModel.selectedCountryRegion.collectAsState()&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Ajustes&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Volver atrás&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = { /* TODO: Implementar función de comentarios/chat */ }) {&#10;                        Icon(painter = painterResource(id = R.drawable.ic_outline_chat_bubble_24), contentDescription = &quot;Comentarios&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        val scrollState = rememberScrollState()&#10;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;                .verticalScroll(scrollState)&#10;        ) {&#10;            // Sección de Cuenta&#10;            SettingsSection(title = &quot;Cuenta&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_account_circle_24),&#10;                        text = &quot;Iniciar sesión&quot;,&#10;                        onClick = { /* TODO: Implementar inicio de sesión (requiere Firebase Auth) */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Opción para configurar credenciales MQTT&#10;            SettingsCard {&#10;                SettingsItem(&#10;                    icon = painterResource(id = R.drawable.ic_baseline_cloud_24),&#10;                    text = &quot;Configurar MQTT&quot;,&#10;                    onClick = navigateToMqttSettings,&#10;                    trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                )&#10;            }&#10;&#10;            SettingsSection(title = &quot;Desarrollo (Temporal)&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_outline_laptop_windows_24),&#10;                        text = &quot;Ver Detalle Terrario (DEV)&quot;,&#10;                        onClick = navigateToTerrariumDetailPlaceholder, // Navega a la nueva pantalla&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                }&#10;            }&#10;            // --- FIN NUEVA SECCIÓN ---&#10;&#10;            // Sección de Compartir&#10;            SettingsSection(title = &quot;Compartir&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_share_24),&#10;                        text = &quot;Se ha compartido&quot;,&#10;                        onClick = { /* TODO: Implementar compartir */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_qr_code_24),&#10;                        text = &quot;Mi código QR&quot;,&#10;                        onClick = { /* TODO: Implementar QR */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Sección de Actualizaciones&#10;            SettingsSection(title = &quot;Actualizaciones&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_outline_cell_wifi_24),&#10;                        text = &quot;Actualizar con datos móviles&quot;,&#10;                        onClick = { viewModel.setAutoUpdateMobileData(!autoUpdateMobileData) },&#10;                        trailingContent = {&#10;                            Switch(&#10;                                checked = autoUpdateMobileData,&#10;                                onCheckedChange = { viewModel.setAutoUpdateMobileData(it) }&#10;                            )&#10;                        }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_wifi_24),&#10;                        text = &quot;Actualizar plug-ins vía Wi-Fi&quot;,&#10;                        onClick = { viewModel.setAutoUpdateWifi(!autoUpdateWifi) },&#10;                        trailingContent = {&#10;                            Switch(&#10;                                checked = autoUpdateWifi,&#10;                                onCheckedChange = { viewModel.setAutoUpdateWifi(it) }&#10;                            )&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Sección de Zona Horaria&#10;            SettingsSection(title = &quot;Zona Horaria&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_schedule_24),&#10;                        text = &quot;Zona Horaria&quot;,&#10;                        onClick = navigateToTimeZoneSelection,&#10;                        trailingContent = {&#10;                            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                                Text(&#10;                                    text = selectedTimeZoneId ?: TimeZone.getDefault().id,&#10;                                    style = MaterialTheme.typography.bodyLarge,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Sección de País/Región&#10;            SettingsSection(title = &quot;País/Región&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_outline_flag_2_24),&#10;                        text = &quot;País/Región&quot;,&#10;                        onClick = navigateToCountryRegionSelection,&#10;                        trailingContent = {&#10;                            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                                Text(&#10;                                    text = selectedCountryRegion ?: Locale.getDefault().displayCountry,&#10;                                    style = MaterialTheme.typography.bodyLarge,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Sección de Información&#10;            SettingsSection(title = &quot;Información&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_outline_search_24),&#10;                        text = &quot;Buscar actualizaciones&quot;,&#10;                        onClick = { /* TODO: Implementar búsqueda de actualizaciones */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_smartphone_24),&#10;                        text = &quot;Actualizaciones del dispositivo&quot;,&#10;                        onClick = { /* TODO: Implementar actualizaciones del dispositivo */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_help_24),&#10;                        text = &quot;Ayuda&quot;,&#10;                        onClick = { /* TODO: Implementar ayuda */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_info_24),&#10;                        text = &quot;Acerca de&quot;,&#10;                        onClick = { /* TODO: Implementar Acerca de */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsCard(content: @Composable () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        elevation = CardDefaults.cardElevation(2.dp),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;    ) {&#10;        Column(modifier = Modifier.fillMaxWidth()) {&#10;            content()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsItem(&#10;    icon: Any?,&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    trailingContent: @Composable (() -&gt; Unit)? = null&#10;) {&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick)&#10;            .padding(horizontal = 16.dp, vertical = 12.dp),&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.SpaceBetween&#10;    ) {&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            if (icon is ImageVector) {&#10;                Icon(&#10;                    imageVector = icon,&#10;                    contentDescription = null,&#10;                    tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            } else if (icon is Painter) {&#10;                Icon(&#10;                    painter = icon,&#10;                    contentDescription = null,&#10;                    tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            Text(&#10;                text = text,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;        trailingContent?.invoke()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsSection(title: String, content: @Composable () -&gt; Unit) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(top = 16.dp)&#10;    ) {&#10;        Text(&#10;            text = title,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = MaterialTheme.colorScheme.primary,&#10;            modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;        )&#10;        content()&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SettingsScreenPreview() {&#10;    ReptiTrackTheme {&#10;        SettingsScreen(&#10;            onBackClick = {},&#10;            navigateToTimeZoneSelection = {},&#10;            navigateToCountryRegionSelection = {},&#10;            navigateToMqttSettings = {},&#10;            // ¡NUEVO! Añade este parámetro al Preview también&#10;            navigateToTerrariumDetailPlaceholder = {}&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.screens.settings&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.painter.Painter&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.waldoz_x.reptitrack.R&#10;import com.waldoz_x.reptitrack.ui.theme.ReptiTrackTheme&#10;import java.util.TimeZone&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SettingsScreen(&#10;    onBackClick: () -&gt; Unit,&#10;    navigateToTimeZoneSelection: () -&gt; Unit,&#10;    navigateToCountryRegionSelection: () -&gt; Unit,&#10;    navigateToMqttSettings: () -&gt; Unit,&#10;    // ¡NUEVO! Añade este parámetro para la navegación temporal al detalle del terrario&#10;    navigateToTerrariumDetailPlaceholder: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: SettingsViewModel = hiltViewModel()&#10;) {&#10;    val autoUpdateMobileData by viewModel.autoUpdateMobileData.collectAsState()&#10;    val autoUpdateWifi by viewModel.autoUpdateWifi.collectAsState()&#10;    val selectedTimeZoneId by viewModel.selectedTimeZoneId.collectAsState()&#10;    val selectedCountryRegion by viewModel.selectedCountryRegion.collectAsState()&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Ajustes&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;Volver atrás&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = { /* TODO: Implementar función de comentarios/chat */ }) {&#10;                        Icon(painter = painterResource(id = R.drawable.ic_outline_chat_bubble_24), contentDescription = &quot;Comentarios&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        val scrollState = rememberScrollState()&#10;&#10;        Column(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(MaterialTheme.colorScheme.background)&#10;                .verticalScroll(scrollState)&#10;        ) {&#10;            // Sección de Cuenta&#10;            SettingsSection(title = &quot;Cuenta&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_account_circle_24),&#10;                        text = &quot;Iniciar sesión&quot;,&#10;                        onClick = { /* TODO: Implementar inicio de sesión (requiere Firebase Auth) */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Opción para configurar credenciales MQTT&#10;            SettingsCard {&#10;                SettingsItem(&#10;                    icon = painterResource(id = R.drawable.ic_baseline_cloud_24),&#10;                    text = &quot;Configurar MQTT&quot;,&#10;                    onClick = navigateToMqttSettings,&#10;                    trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                )&#10;            }&#10;&#10;            SettingsSection(title = &quot;Desarrollo (Temporal)&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_outline_laptop_windows_24),&#10;                        text = &quot;Mi terrario&quot;, // Cambiado de &quot;Ver Detalle Terrario (DEV)&quot;&#10;                        onClick = navigateToTerrariumDetailPlaceholder, // Navega a la nueva pantalla&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                }&#10;            }&#10;            // --- FIN NUEVA SECCIÓN ---&#10;&#10;            // Sección de Compartir&#10;            SettingsSection(title = &quot;Compartir&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_share_24),&#10;                        text = &quot;Se ha compartido&quot;,&#10;                        onClick = { /* TODO: Implementar compartir */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_qr_code_24),&#10;                        text = &quot;Mi código QR&quot;,&#10;                        onClick = { /* TODO: Implementar QR */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Sección de Actualizaciones&#10;            SettingsSection(title = &quot;Actualizaciones&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_outline_cell_wifi_24),&#10;                        text = &quot;Actualizar con datos móviles&quot;,&#10;                        onClick = { viewModel.setAutoUpdateMobileData(!autoUpdateMobileData) },&#10;                        trailingContent = {&#10;                            Switch(&#10;                                checked = autoUpdateMobileData,&#10;                                onCheckedChange = { viewModel.setAutoUpdateMobileData(it) }&#10;                            )&#10;                        }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_wifi_24),&#10;                        text = &quot;Actualizar plug-ins vía Wi-Fi&quot;,&#10;                        onClick = { viewModel.setAutoUpdateWifi(!autoUpdateWifi) },&#10;                        trailingContent = {&#10;                            Switch(&#10;                                checked = autoUpdateWifi,&#10;                                onCheckedChange = { viewModel.setAutoUpdateWifi(it) }&#10;                            )&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Sección de Zona Horaria&#10;            SettingsSection(title = &quot;Zona Horaria&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_schedule_24),&#10;                        text = &quot;Zona Horaria&quot;,&#10;                        onClick = navigateToTimeZoneSelection,&#10;                        trailingContent = {&#10;                            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                                Text(&#10;                                    text = selectedTimeZoneId ?: TimeZone.getDefault().id,&#10;                                    style = MaterialTheme.typography.bodyLarge,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Sección de País/Región&#10;            SettingsSection(title = &quot;País/Región&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_outline_flag_2_24),&#10;                        text = &quot;País/Región&quot;,&#10;                        onClick = navigateToCountryRegionSelection,&#10;                        trailingContent = {&#10;                            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                                Text(&#10;                                    text = selectedCountryRegion ?: Locale.getDefault().displayCountry,&#10;                                    style = MaterialTheme.typography.bodyLarge,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Sección de Información&#10;            SettingsSection(title = &quot;Información&quot;) {&#10;                SettingsCard {&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_outline_search_24),&#10;                        text = &quot;Buscar actualizaciones&quot;,&#10;                        onClick = { /* TODO: Implementar búsqueda de actualizaciones */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_smartphone_24),&#10;                        text = &quot;Actualizaciones del dispositivo&quot;,&#10;                        onClick = { /* TODO: Implementar actualizaciones del dispositivo */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_help_24),&#10;                        text = &quot;Ayuda&quot;,&#10;                        onClick = { /* TODO: Implementar ayuda */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                    HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))&#10;                    SettingsItem(&#10;                        icon = painterResource(id = R.drawable.ic_baseline_info_24),&#10;                        text = &quot;Acerca de&quot;,&#10;                        onClick = { /* TODO: Implementar Acerca de */ },&#10;                        trailingContent = { Icon(Icons.AutoMirrored.Filled.KeyboardArrowRight, contentDescription = &quot;Ir a&quot;) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsCard(content: @Composable () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        elevation = CardDefaults.cardElevation(2.dp),&#10;        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;    ) {&#10;        Column(modifier = Modifier.fillMaxWidth()) {&#10;            content()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsItem(&#10;    icon: Any?,&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    trailingContent: @Composable (() -&gt; Unit)? = null&#10;) {&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick)&#10;            .padding(horizontal = 16.dp, vertical = 12.dp),&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.SpaceBetween&#10;    ) {&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            if (icon is ImageVector) {&#10;                Icon(&#10;                    imageVector = icon,&#10;                    contentDescription = null,&#10;                    tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            } else if (icon is Painter) {&#10;                Icon(&#10;                    painter = icon,&#10;                    contentDescription = null,&#10;                    tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            Text(&#10;                text = text,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;        trailingContent?.invoke()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SettingsSection(title: String, content: @Composable () -&gt; Unit) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(top = 16.dp)&#10;    ) {&#10;        Text(&#10;            text = title,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = MaterialTheme.colorScheme.primary,&#10;            modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;        )&#10;        content()&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun SettingsScreenPreview() {&#10;    ReptiTrackTheme {&#10;        SettingsScreen(&#10;            onBackClick = {},&#10;            navigateToTimeZoneSelection = {},&#10;            navigateToCountryRegionSelection = {},&#10;            navigateToMqttSettings = {},&#10;            // ¡NUEVO! Añade este parámetro al Preview también&#10;            navigateToTerrariumDetailPlaceholder = {}&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/screens/terrariumdetail/TerrariumDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/screens/terrariumdetail/TerrariumDetailScreen.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.screens.terrariumdetail&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.waldoz_x.reptitrack.ui.theme.ReptiTrackTheme&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import java.util.Locale&#10;import java.time.LocalTime // Import LocalTime&#10;import java.time.temporal.ChronoUnit // Import ChronoUnit&#10;import kotlinx.coroutines.delay // Import delay for LaunchedEffect&#10;import androidx.compose.runtime.LaunchedEffect // Import LaunchedEffect&#10;&#10;// Imports for using Painter and painterResource&#10;import androidx.compose.ui.graphics.painter.Painter&#10;import androidx.compose.ui.res.painterResource&#10;import com.waldoz_x.reptitrack.R // Make sure to import your R class to access drawables&#10;&#10;// Import for loading images asynchronously (Coil) - Not directly used for background images now, but kept for future use if needed&#10;import coil.compose.AsyncImage&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.foundation.layout.FlowRow&#10;import androidx.compose.foundation.layout.ExperimentalLayoutApi&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.foundation.BorderStroke // Import BorderStroke&#10;import androidx.compose.animation.animateColorAsState // Import animateColorAsState&#10;import androidx.compose.foundation.Canvas // Import Canvas for drawing circles&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.foundation.border&#10;import androidx.compose.ui.draw.shadow&#10;import com.waldoz_x.reptitrack.ui.components.Dht22SensorGroupCard&#10;import com.waldoz_x.reptitrack.ui.components.Ds18b20SensorGroupCard&#10;import com.waldoz_x.reptitrack.ui.components.OtherSensorsGroupCard&#10;import com.waldoz_x.reptitrack.ui.components.ActuatorControlCard&#10;import com.waldoz_x.reptitrack.ui.components.FoodDispenserCard&#10;import com.waldoz_x.reptitrack.ui.components.RainSystemCard&#10;&#10;// Definition of filter categories&#10;enum class TerrariumCategory(val displayName: String) {&#10;    ALL(&quot;Todo&quot;),&#10;    SENSORS(&quot;Sensores&quot;),&#10;    LIGHTS(&quot;Iluminación&quot;),&#10;    CLIMATE_WATER(&quot;Clima y Agua&quot;),&#10;    RAIN_SYSTEM(&quot;Sistema de Lluvia&quot;), // Nueva categoría&#10;    OTHER_SENSORS(&quot;Otros Sensores&quot;)&#10;}&#10;&#10;// This is the terrarium detail screen&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)&#10;@Composable&#10;fun TerrariumDetailScreen(&#10;    terrariumId: String,&#10;    onBackClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: TerrariumDetailViewModel = hiltViewModel()&#10;) {&#10;    // Observe terrarium state from the ViewModel&#10;    val terrariumState by viewModel.terrariumState.collectAsState()&#10;    val sensorData by viewModel.sensorData.collectAsState()&#10;    val actuatorStates by viewModel.actuatorStates.collectAsState()&#10;    val isMqttConnected by viewModel.isMqttConnected.collectAsState()&#10;&#10;    // State for category filter&#10;    var selectedCategory by remember { mutableStateOf(TerrariumCategory.ALL) }&#10;&#10;    // --- Logic to handle real vs. mock data ---&#10;    // If terrariumState is null, it means no real terrarium has been loaded (or we are in preview/mock mode)&#10;    val useMockData = terrariumState == null &amp;&amp; terrariumId == &quot;placeholder_terrarium_id&quot;&#10;&#10;    val currentTerrarium = if (useMockData) createMockTerrarium(terrariumId) else terrariumState&#10;    val currentSensorData = if (useMockData) createMockSensorData() else sensorData&#10;    // We use a local mutable state for mock actuators so they respond to the UI&#10;    var mockActuatorStates by remember { mutableStateOf(createMockActuatorStates()) }&#10;    val currentActuatorStates = if (useMockData) mockActuatorStates else actuatorStates&#10;    val currentMqttConnected = if (useMockData) true else isMqttConnected // Assume connected in mock&#10;&#10;    // Calcula el promedio de temperatura de los DHT22 (para &quot;Temperatura Actual&quot;)&#10;    val dhtTemperatures = currentSensorData.filterKeys { it.startsWith(&quot;dht22_&quot;) &amp;&amp; it.endsWith(&quot;_temperature&quot;) }&#10;        .mapNotNull { it.value.replace(&quot;°C&quot;, &quot;&quot;).toFloatOrNull() }&#10;    val averageDhtTemperature = if (dhtTemperatures.isNotEmpty()) {&#10;        String.format(Locale.getDefault(), &quot;%.1f°C&quot;, dhtTemperatures.average())&#10;    } else &quot;N/A&quot;&#10;&#10;    // Calcula el promedio de temperatura de los DS18B20 (para &quot;Temp. Promedio&quot;)&#10;    val dsTemperatures = currentSensorData.filterKeys { it.startsWith(&quot;ds18b20_&quot;) &amp;&amp; it.endsWith(&quot;_temperature&quot;) }&#10;        .mapNotNull { it.value.replace(&quot;°C&quot;, &quot;&quot;).toFloatOrNull() }&#10;    val averageDsTemperature = if (dsTemperatures.isNotEmpty()) {&#10;        String.format(Locale.getDefault(), &quot;%.1f°C&quot;, dsTemperatures.average())&#10;    } else &quot;N/A&quot;&#10;&#10;    // Calcula el promedio de humedad de los DHT22 (para &quot;Hum. Promedio&quot;)&#10;    val dhtHumidities = currentSensorData.filterKeys { it.startsWith(&quot;dht22_&quot;) &amp;&amp; it.endsWith(&quot;_humidity&quot;) }&#10;        .mapNotNull { it.value.replace(&quot;%&quot;, &quot;&quot;).toFloatOrNull() }&#10;    val averageHumidity = if (dhtHumidities.isNotEmpty()) {&#10;        String.format(Locale.getDefault(), &quot;%.1f%%&quot;, dhtHumidities.average())&#10;    } else &quot;N/A&quot;&#10;&#10;    // &quot;Temperatura Actual&quot; ahora es el promedio de los DHT22&#10;    val mainTemperature = averageDhtTemperature&#10;&#10;    val lastUpdatedText = currentSensorData[&quot;lastUpdated&quot;] ?: &quot;N/A&quot;&#10;&#10;    // --- Logic for dynamic background (Day/Night) ---&#10;    var isDayTime by remember { mutableStateOf(isCurrentlyDayTime()) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            val now = LocalTime.now()&#10;            val nextMinuteStart = now.plusMinutes(1).truncatedTo(ChronoUnit.MINUTES)&#10;            val delayMillis = now.until(nextMinuteStart, ChronoUnit.MILLIS)&#10;            delay(delayMillis) // Wait until the start of the next minute&#10;            isDayTime = isCurrentlyDayTime()&#10;        }&#10;    }&#10;&#10;    // Background images (User needs to provide these in res/drawable)&#10;    val dayBackgroundImage = painterResource(id = R.drawable.jungle_background)&#10;    val nightBackgroundImage = painterResource(id = R.drawable.night_background_image)&#10;&#10;    val currentBackgroundImage = if (isDayTime) dayBackgroundImage else nightBackgroundImage&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    // Consider externalizing this string to strings.xml&#10;                    Text(&#10;                        text = &quot;Terrario: ${currentTerrarium?.name ?: terrariumId}&quot;,&#10;                        color = Color.Black // Changed text color to black&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        // Consider externalizing this description to strings.xml&#10;                        Icon(&#10;                            Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver atrás&quot;,&#10;                            tint = Color.Black // Changed icon tint to black&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = { /* TODO: Implement more options if necessary */ }) {&#10;                        // Consider externalizing this description to strings.xml&#10;                        Icon(&#10;                            Icons.Default.Info,&#10;                            contentDescription = &quot;Más información&quot;,&#10;                            tint = Color.Black // Changed icon tint to black&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent) // Transparent TopAppBar&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        val scrollState = rememberScrollState()&#10;        Box(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues) // Apply Scaffold padding here&#10;        ) {&#10;            // 1. Background Image (bottom layer)&#10;            Image(&#10;                painter = currentBackgroundImage,&#10;                contentDescription = &quot;Fondo del terrario&quot;, // Consider externalizing&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentScale = ContentScale.Crop // Scale to fill, cropping if necessary&#10;            )&#10;&#10;            // Removed the intermediate transparent Card as per user request&#10;&#10;            // 3. Existing functional cards (top layer) - this is the current Column content&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .verticalScroll(scrollState)&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp), // Keep original padding for content&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Spacer(modifier = Modifier.height(8.dp)) // Top space&#10;&#10;                // Show a loading indicator only if we are NOT using mock data and the terrarium has not yet loaded&#10;                if (terrariumState == null &amp;&amp; !useMockData) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        // Consider externalizing this string to strings.xml&#10;                        Text(&#10;                            text = &quot;Cargando datos del terrario...&quot;,&#10;                            modifier = Modifier.padding(top = 80.dp),&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                } else {&#10;                    // Main screen content, visible when terrarium is loaded or in mock mode&#10;                    AnimatedVisibility(&#10;                        visible = currentTerrarium != null, // Visible if currentTerrarium has data (real or mock)&#10;                        enter = fadeIn(animationSpec = tween(durationMillis = 500)),&#10;                        exit = fadeOut(animationSpec = tween(durationMillis = 500))&#10;                    ) {&#10;                        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                            // General Summary Card with terrarium photo&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(bottom = 16.dp)&#10;                                    .animateContentSize(animationSpec = tween(durationMillis = 300)), // Size animation&#10;                                shape = RoundedCornerShape(24.dp), // Increased rounded corners&#10;                                elevation = CardDefaults.cardElevation(8.dp), // Higher elevation to make it stand out&#10;                                // Use a darker, transparent color for the primary container&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFF4A5C70).copy(alpha = 0.8f)) // Darker, transparent blue-grey&#10;                            ) {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(20.dp) // More internal padding&#10;                                ) {&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically,&#10;                                        horizontalArrangement = Arrangement.SpaceBetween&#10;                                    ) {&#10;                                        Column(modifier = Modifier.weight(1f)) {&#10;                                            // Consider externalizing this string to strings.xml&#10;                                            Text(&#10;                                                text = &quot;Gestión del Terrario&quot;,&#10;                                                style = MaterialTheme.typography.headlineSmall,&#10;                                                fontWeight = FontWeight.ExtraBold, // Bolder&#10;                                                color = Color.White // Text color white&#10;                                            )&#10;                                            Spacer(modifier = Modifier.height(6.dp)) // More space&#10;                                            // Consider externalizing this string to strings.xml&#10;                                            Text(&#10;                                                text = &quot;Monitorea y controla tu terrario en tiempo real.&quot;,&#10;                                                style = MaterialTheme.typography.bodyMedium,&#10;                                                color = Color.LightGray // Text color light gray&#10;                                            )&#10;                                        }&#10;                                        Spacer(modifier = Modifier.width(20.dp)) // More space&#10;                                        // Terrarium photo (ALWAYS FROM DRAWABLE)&#10;                                        Box(&#10;                                            modifier = Modifier&#10;                                                .size(120.dp) // Slightly larger size&#10;                                                .clip(RoundedCornerShape(24.dp)) // Ensures the image is clipped with rounded corners&#10;                                                .background(Color(0xFF81C784).copy(alpha = 0.2f)), // Subtle background that matches the theme&#10;                                            contentAlignment = Alignment.Center&#10;                                        ) {&#10;                                            // IMPORTANT: CHANGE 'R.drawable.ic_baseline_cloud_24' to your REAL terrarium image ID!&#10;                                            // This is a placeholder.&#10;                                            Image(&#10;                                                painter = painterResource(id = R.drawable.terrario), // &lt;-- Your image goes here!&#10;                                                contentDescription = &quot;Imagen del Terrario&quot;, // Consider externalizing&#10;                                                modifier = Modifier&#10;                                                    .fillMaxSize()&#10;                                                    .clip(RoundedCornerShape(24.dp)), // Clip image with rounded corners&#10;                                                contentScale = ContentScale.Crop // Scale to fill space&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                    Spacer(modifier = Modifier.height(20.dp)) // More space&#10;                                    Row(&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.Info, // Example icon, you can change it&#10;                                            contentDescription = &quot;Estado de conexión&quot;, // Consider externalizing&#10;                                            // Use theme colors for connection status&#10;                                            tint = if (currentMqttConnected) Color(0xFF4CAF50) else Color(0xFFD32F2F), // Green for connected, Red for disconnected&#10;                                            modifier = Modifier.size(28.dp) // Slightly larger icon&#10;                                        )&#10;                                        Spacer(modifier = Modifier.width(10.dp)) // More space&#10;                                        Text(&#10;                                            // Consider externalizing these strings to strings.xml&#10;                                            text = if (currentMqttConnected) &quot;Conectado al ESP32&quot; else &quot;Desconectado del ESP32&quot;,&#10;                                            style = MaterialTheme.typography.titleMedium, // More prominent text&#10;                                            fontWeight = FontWeight.SemiBold,&#10;                                            color = if (currentMqttConnected) Color(0xFF4CAF50) else Color(0xFFD32F2F)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // Prominent Temperature and Humidity Section (Improved)&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(bottom = 16.dp)&#10;                                    .animateContentSize(animationSpec = tween(durationMillis = 300)),&#10;                                shape = RoundedCornerShape(24.dp), // Increased rounded corners&#10;                                elevation = CardDefaults.cardElevation(4.dp), // Higher elevation&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFF2D3A4B).copy(alpha = 0.7f)) // Darker, transparent blue-grey&#10;                            ) {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(20.dp) // More padding&#10;                                ) {&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically,&#10;                                        horizontalArrangement = Arrangement.SpaceBetween&#10;                                    ) {&#10;                                        Column {&#10;                                            Text(&#10;                                                text = mainTemperature,&#10;                                                style = MaterialTheme.typography.displaySmall, // Larger text size&#10;                                                fontWeight = FontWeight.ExtraBold,&#10;                                                color = Color.White // Text color white&#10;                                            )&#10;                                            Text(&#10;                                                text = &quot;Temperatura Actual&quot;, // Consider externalizing&#10;                                                style = MaterialTheme.typography.bodyLarge, // Larger text&#10;                                                color = Color.LightGray // Text color light gray&#10;                                            )&#10;                                        }&#10;                                        Icon(&#10;                                            painter = getSensorIcon(&quot;temperature&quot;),&#10;                                            contentDescription = &quot;Temperatura&quot;, // Consider externalizing&#10;                                            tint = Color.White, // Icon color white&#10;                                            modifier = Modifier.size(64.dp) // Larger icon&#10;                                        )&#10;                                    }&#10;                                    Spacer(modifier = Modifier.height(16.dp)) // Space between main temperature and averages&#10;&#10;                                    Divider(modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp), color = Color.White.copy(alpha = 0.3f)) // Separator with transparency&#10;&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        horizontalArrangement = Arrangement.SpaceAround,&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        // Average Humidity&#10;                                        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                            Icon(&#10;                                                painter = getSensorIcon(&quot;humidity&quot;),&#10;                                                contentDescription = &quot;Humedad Promedio&quot;, // Consider externalizing&#10;                                                tint = Color.White, // Icon color white&#10;                                                modifier = Modifier.size(40.dp)&#10;                                            )&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;                                            Text(&#10;                                                text = averageHumidity,&#10;                                                style = MaterialTheme.typography.titleLarge,&#10;                                                fontWeight = FontWeight.Bold,&#10;                                                color = Color.White // Text color white&#10;                                            )&#10;                                            Text(&#10;                                                text = &quot;Hum. Promedio&quot;, // Consider externalizing&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                color = Color.LightGray // Text color light gray&#10;                                            )&#10;                                        }&#10;&#10;                                        // Average Temperature (if different from main, or as a second indicator)&#10;                                        // You could decide to show it only if it's significantly different from mainTemperature&#10;                                        // Or simply as a &quot;general average&quot; vs &quot;current&quot;&#10;                                        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                            Icon(&#10;                                                painter = getSensorIcon(&quot;temperature&quot;),&#10;                                                contentDescription = &quot;Temperatura Promedio&quot;, // Consider externalizing&#10;                                                tint = Color.White, // Icon color white&#10;                                                modifier = Modifier.size(40.dp)&#10;                                            )&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;                                            Text(&#10;                                                text = averageDsTemperature,&#10;                                                style = MaterialTheme.typography.titleLarge,&#10;                                                fontWeight = FontWeight.Bold,&#10;                                                color = Color.White // Text color white&#10;                                            )&#10;                                            Text(&#10;                                                text = &quot;Temp. Promedio&quot;, // Consider externalizing&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                color = Color.LightGray // Text color light gray&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // Last Updated Card (New addition for better visibility)&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(bottom = 16.dp)&#10;                                    .animateContentSize(animationSpec = tween(durationMillis = 300)),&#10;                                shape = RoundedCornerShape(16.dp),&#10;                                elevation = CardDefaults.cardElevation(2.dp),&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFF607D8B).copy(alpha = 0.6f)) // Lighter transparent blue-grey&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically,&#10;                                    horizontalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = R.drawable.outline_mode_fan_24), // Using a clock icon&#10;                                        contentDescription = &quot;Última Actualización&quot;,&#10;                                        tint = Color.White,&#10;                                        modifier = Modifier.size(20.dp)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&#10;                                        text = &quot;Última Actualización: $lastUpdatedText&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        fontWeight = FontWeight.SemiBold,&#10;                                        color = Color.White,&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;&#10;                            // Filter Section&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            // Consider externalizing this string to strings.xml&#10;                            Text(&#10;                                text = &quot;Filtrar por:&quot;,&#10;                                style = MaterialTheme.typography.titleSmall,&#10;                                color = Color.White, // Text color white&#10;                                modifier = Modifier.align(Alignment.Start).padding(start = 4.dp, bottom = 4.dp)&#10;                            )&#10;                            FlowRow(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                TerrariumCategory.values().forEach { category -&gt;&#10;                                    CategoryFilterChip(&#10;                                        category = category,&#10;                                        selected = selectedCategory == category,&#10;                                        onClick = { selectedCategory = category }&#10;                                    )&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                            // --- Sensor Data Display (Refactored) ---&#10;                            // DHT22 Sensors Group&#10;                            AnimatedVisibility(&#10;                                visible = selectedCategory == TerrariumCategory.ALL || selectedCategory == TerrariumCategory.SENSORS || selectedCategory == TerrariumCategory.CLIMATE_WATER,&#10;                                enter = fadeIn(animationSpec = tween(durationMillis = 300)),&#10;                                exit = fadeOut(animationSpec = tween(durationMillis = 300))&#10;                            ) {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Temperatura Hambiente&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    // Cuadrícula 2x2 para los sensores DHT22&#10;                                    Column(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                    ) {&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.SpaceEvenly&#10;                                        ) {&#10;                                            Dht22SensorGroupCard(sensorNumber = 1, sensorData = currentSensorData)&#10;                                            Dht22SensorGroupCard(sensorNumber = 2, sensorData = currentSensorData)&#10;                                        }&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.SpaceEvenly&#10;                                        ) {&#10;                                            Dht22SensorGroupCard(sensorNumber = 3, sensorData = currentSensorData)&#10;                                            Dht22SensorGroupCard(sensorNumber = 4, sensorData = currentSensorData)&#10;                                        }&#10;                                    }&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;                                }&#10;                            }&#10;&#10;                            // DS18B20 Sensors Group y Otros Sensores&#10;                            AnimatedVisibility(&#10;                                visible = selectedCategory == TerrariumCategory.ALL || selectedCategory == TerrariumCategory.SENSORS || selectedCategory == TerrariumCategory.OTHER_SENSORS,&#10;                                enter = fadeIn(animationSpec = tween(durationMillis = 300)),&#10;                                exit = fadeOut(animationSpec = tween(durationMillis = 300))&#10;                            ) {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Temperatura del Suelo&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    Ds18b20SensorGroupCard(sensorData = currentSensorData)&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                                    Text(&#10;                                        text = &quot;Otros Sensores&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    // Solo muestra la potencia del sensor pzem004&#10;                                    val powerValue = currentSensorData[&quot;pzem_1_power&quot;] ?: &quot;N/A&quot;&#10;                                    Row(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(vertical = 8.dp),&#10;                                        horizontalArrangement = Arrangement.Center,&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Icon(&#10;                                            painter = getSensorIcon(&quot;power&quot;),&#10;                                            contentDescription = &quot;Potencia&quot;,&#10;                                            tint = Color.White,&#10;                                            modifier = Modifier.size(32.dp)&#10;                                        )&#10;                                        Spacer(modifier = Modifier.width(8.dp))&#10;                                        Text(&#10;                                            text = powerValue,&#10;                                            style = MaterialTheme.typography.titleLarge,&#10;                                            color = Color.White&#10;                                        )&#10;                                    }&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;                                }&#10;                            }&#10;&#10;                            // Actuator Controls&#10;                            AnimatedVisibility(&#10;                                visible = selectedCategory == TerrariumCategory.ALL || selectedCategory == TerrariumCategory.LIGHTS || selectedCategory == TerrariumCategory.CLIMATE_WATER,&#10;                                enter = fadeIn(animationSpec = tween(durationMillis = 300)),&#10;                                exit = fadeOut(animationSpec = tween(durationMillis = 300))&#10;                            ) {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Controles de Actuadores&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    // Cuadrícula de actuadores en 2 columnas&#10;                                    val actuatorList = currentActuatorStates&#10;                                        .filterKeys { it != &quot;water_pump_active&quot; }&#10;                                        .toList()&#10;                                    Column(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                    ) {&#10;                                        actuatorList.chunked(2).forEach { rowActuators -&gt;&#10;                                            Row(&#10;                                                modifier = Modifier.fillMaxWidth(),&#10;                                                horizontalArrangement = Arrangement.SpaceEvenly&#10;                                            ) {&#10;                                                rowActuators.forEach { (key, isActive) -&gt;&#10;                                                    ActuatorControlCard(&#10;                                                        actuatorKey = key,&#10;                                                        isActive = isActive,&#10;                                                        onToggle = { newState -&gt;&#10;                                                            if (useMockData) {&#10;                                                                mockActuatorStates = mockActuatorStates.toMutableMap().apply {&#10;                                                                    this[key] = newState&#10;                                                                }&#10;                                                            } else {&#10;                                                                currentTerrarium?.let { terrarium -&gt;&#10;                                                                    viewModel.toggleActuator(terrarium.id, key, newState)&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // Nueva sección destacada para el dispensador de comida&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(bottom = 16.dp)&#10;                                    .animateContentSize(animationSpec = tween(durationMillis = 300)),&#10;                                shape = RoundedCornerShape(24.dp),&#10;                                elevation = CardDefaults.cardElevation(8.dp),&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFFFFC107).copy(alpha = 0.8f)) // Color amarillo para destacar&#10;                            ) {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(20.dp),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally&#10;                                ) {&#10;                                    FoodDispenserCard(&#10;                                        isActive = currentActuatorStates[&quot;food_dispenser_active&quot;] ?: false,&#10;                                        loads = currentSensorData[&quot;food_dispenser_loads&quot;]?.toIntOrNull() ?: 0,&#10;                                        onDispense = { newState -&gt;&#10;                                            if (useMockData) {&#10;                                                mockActuatorStates = mockActuatorStates.toMutableMap().apply {&#10;                                                    this[&quot;food_dispenser_active&quot;] = newState&#10;                                                }&#10;                                            } else {&#10;                                                currentTerrarium?.let { terrarium -&gt;&#10;                                                    viewModel.toggleActuator(terrarium.id, &quot;food_dispenser_active&quot;, newState)&#10;                                                }&#10;                                            }&#10;                                        },&#10;                                        onRecharge = {&#10;                                            // Aquí puedes poner la lógica para recargar el dispensador.&#10;                                            // Por ejemplo, podrías mostrar un diálogo, enviar un comando, etc.&#10;                                            // Si no tienes lógica aún, puedes dejarlo vacío.&#10;                                        }&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            // Sistema de Lluvia (Rain System)&#10;                            AnimatedVisibility(&#10;                                visible = selectedCategory == TerrariumCategory.ALL || selectedCategory == TerrariumCategory.RAIN_SYSTEM,&#10;                                enter = fadeIn(animationSpec = tween(durationMillis = 300)),&#10;                                exit = fadeOut(animationSpec = tween(durationMillis = 300))&#10;                            ) {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Sistema de Lluvia&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    RainSystemCard(&#10;                                        isActive = currentActuatorStates[&quot;water_pump_active&quot;] ?: false,&#10;                                        waterDistance = currentSensorData[&quot;hc_sr04_1_distance&quot;]?.replace(&quot; cm&quot;, &quot;&quot;)?.toFloatOrNull(),&#10;                                        onToggle = { newState -&gt;&#10;                                            if (useMockData) {&#10;                                                mockActuatorStates = mockActuatorStates.toMutableMap().apply {&#10;                                                    this[&quot;water_pump_active&quot;] = newState&#10;                                                }&#10;                                            } else {&#10;                                                currentTerrarium?.let { terrarium -&gt;&#10;                                                    viewModel.toggleActuator(terrarium.id, &quot;water_pump_active&quot;, newState)&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;// Mejoras en los filtros: iconos y colores por categoría&#10;@Composable&#10;fun CategoryFilterChip(&#10;    category: TerrariumCategory,&#10;    selected: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    val icon: Painter = when (category) {&#10;        TerrariumCategory.ALL -&gt; painterResource(id = R.drawable.ic_baseline_cloud_24)&#10;        TerrariumCategory.SENSORS -&gt; painterResource(id = R.drawable.ic_baseline_thermostat_24)&#10;        TerrariumCategory.LIGHTS -&gt; painterResource(id = R.drawable.baseline_lightbulb_24)&#10;        TerrariumCategory.CLIMATE_WATER -&gt; painterResource(id = R.drawable.ic_outline_water_pump_24)&#10;        TerrariumCategory.RAIN_SYSTEM -&gt; painterResource(id = R.drawable.ic_outline_water_pump_24) // Usa el mismo ícono o uno diferente si tienes&#10;        TerrariumCategory.OTHER_SENSORS -&gt; painterResource(id = R.drawable.ic_outline_settings_power_24)&#10;    }&#10;    val chipColor = when (category) {&#10;        TerrariumCategory.ALL -&gt; Color(0xFF607D8B)&#10;        TerrariumCategory.SENSORS -&gt; Color(0xFF90CAF9)&#10;        TerrariumCategory.LIGHTS -&gt; Color(0xFFFFF176)&#10;        TerrariumCategory.CLIMATE_WATER -&gt; Color(0xFF80DEEA)&#10;        TerrariumCategory.RAIN_SYSTEM -&gt; Color(0xFF4FC3F7) // Azul para el sistema de lluvia&#10;        TerrariumCategory.OTHER_SENSORS -&gt; Color(0xFFA5D6A7)&#10;    }&#10;&#10;    // Animaciones para el borde y sombra&#10;    val borderWidth by animateDpAsState(targetValue = if (selected) 3.dp else 1.dp)&#10;    val borderColor by animateColorAsState(targetValue = if (selected) chipColor else chipColor.copy(alpha = 0.5f))&#10;    val shadowElevation by animateDpAsState(targetValue = if (selected) 8.dp else 0.dp)&#10;    val backgroundColor by animateColorAsState(targetValue = if (selected) chipColor.copy(alpha = 0.95f) else chipColor.copy(alpha = 0.7f))&#10;&#10;    FilterChip(&#10;        selected = selected,&#10;        onClick = onClick,&#10;        label = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Icon(painter = icon, contentDescription = null, tint = Color.White, modifier = Modifier.size(18.dp))&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;                Text(category.displayName, color = Color.White)&#10;            }&#10;        },&#10;        modifier = Modifier&#10;            .shadow(shadowElevation, RoundedCornerShape(50))&#10;            .border(borderWidth, borderColor, RoundedCornerShape(50)),&#10;        colors = FilterChipDefaults.filterChipColors(&#10;            selectedContainerColor = backgroundColor,&#10;            selectedLabelColor = Color.White,&#10;            containerColor = backgroundColor,&#10;            labelColor = Color.White&#10;        ),&#10;        border = null // El borde se maneja por el modifier&#10;    )&#10;}&#10;&#10;&#10;// Helper function to get health color based on value and type&#10;@Composable&#10;fun getHealthColor(value: Float?, sensorType: String): Color {&#10;    if (value == null) return Color.LightGray.copy(alpha = 0.6f) // For N/A values&#10;&#10;    return when (sensorType) {&#10;        &quot;temperature&quot; -&gt; {&#10;            when {&#10;                value &lt; 20.0f -&gt; Color(0xFFADD8E6) // Light Blue (Cold)&#10;                value &gt; 30.0f -&gt; Color(0xFFFFA07A) // Light Salmon (Hot)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        &quot;humidity&quot; -&gt; {&#10;            when {&#10;                value &lt; 50.0f -&gt; Color(0xFFFFA07A) // Light Salmon (Dry)&#10;                value &gt; 80.0f -&gt; Color(0xFFADD8E6) // Light Blue (Humid)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        &quot;distance&quot; -&gt; {&#10;            when {&#10;                value &lt; 10.0f -&gt; Color(0xFFFFA07A) // Light Salmon (Too close)&#10;                value &gt; 50.0f -&gt; Color(0xFFADD8E6) // Light Blue (Too far)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        &quot;power&quot; -&gt; {&#10;            when {&#10;                value &gt; 100.0f -&gt; Color(0xFFFFA07A) // Light Salmon (High power)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        else -&gt; Color.White // Default&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun getSensorIcon(sensorType: String): Painter {&#10;    return when (sensorType) {&#10;        &quot;temperature&quot; -&gt; painterResource(id = R.drawable.ic_baseline_thermostat_24) // Placeholder, replace with actual icon&#10;        &quot;humidity&quot; -&gt; painterResource(id = R.drawable.ic_outline_humidity_high_24) // Placeholder, replace with actual icon&#10;        &quot;distance&quot; -&gt; painterResource(id = R.drawable.ic_outline_distance_24) // Placeholder, replace with actual icon&#10;        &quot;power&quot; -&gt; painterResource(id = R.drawable.ic_outline_settings_power_24) // Placeholder, replace with actual icon&#10;        else -&gt; painterResource(id = R.drawable.ic_baseline_cloud_24) // Generic placeholder&#10;    }&#10;}&#10;&#10;// Helper function to determine if it's day or night (adjust hours as needed)&#10;fun isCurrentlyDayTime(): Boolean {&#10;    val currentHour = LocalTime.now().hour&#10;    return currentHour in 6..19 // Between 6 AM and 7 PM&#10;}&#10;&#10;// --- Mock Data for Previews ---&#10;fun createMockTerrarium(id: String): Terrarium {&#10;    return Terrarium(&#10;        id = id,&#10;        name = &quot;Terrario de Prueba&quot;,&#10;        description = &quot;Este es un terrario de prueba para desarrollo de UI.&quot;,&#10;        dht22_1_temperature = 25.0f,&#10;        dht22_1_humidity = 70.0f,&#10;        dht22_2_temperature = 26.5f,&#10;        dht22_2_humidity = 65.0f,&#10;        dht22_3_temperature = 19.0f, // Example of low temp&#10;        dht22_3_humidity = 85.0f, // Example of high humidity&#10;        dht22_4_temperature = 32.0f, // Example of high temp&#10;        dht22_4_humidity = 45.0f, // Example of low humidity&#10;        ds18b20_1_temperature = 23.0f,&#10;        ds18b20_2_temperature = 22.5f,&#10;        ds18b20_3_temperature = 24.5f,&#10;        ds18b20_4_temperature = 23.8f,&#10;        ds18b20_5_temperature = 22.0f,&#10;        hc_sr04_1_distance = 5.0f, // Example of low distance&#10;        pzem_1_power = 120.0f, // Example of high power&#10;        // All actuators OFF at start for mock&#10;        waterPumpActive = false,&#10;        fan1Active = false,&#10;        fan2Active = false,&#10;        light1Active = false,&#10;        light2Active = false,&#10;        light3Active = false,&#10;        heatPlate1Active = false,&#10;        lastUpdated = System.currentTimeMillis()&#10;    )&#10;}&#10;&#10;fun createMockSensorData(): Map&lt;String, String&gt; {&#10;    // Mapea los topics y payloads reales a las claves que usa tu UI&#10;    return mapOf(&#10;        // DHT11&#10;        &quot;dht11_1_humidity&quot; to &quot;65.88%&quot;,&#10;        &quot;dht11_1_temperature&quot; to &quot;21.69°C&quot;,&#10;        // DHT22&#10;        &quot;dht22_1_humidity&quot; to &quot;48.66%&quot;,&#10;        &quot;dht22_1_temperature&quot; to &quot;25.11°C&quot;,&#10;        &quot;dht22_2_humidity&quot; to &quot;50.51%&quot;,&#10;        &quot;dht22_2_temperature&quot; to &quot;20.33°C&quot;,&#10;        &quot;dht22_3_humidity&quot; to &quot;55.40%&quot;,&#10;        &quot;dht22_3_temperature&quot; to &quot;27.16°C&quot;,&#10;        &quot;dht22_4_humidity&quot; to &quot;64.87%&quot;,&#10;        &quot;dht22_4_temperature&quot; to &quot;24.49°C&quot;,&#10;        // DS18B20&#10;        &quot;ds18b20_1_temperature&quot; to &quot;34.40°C&quot;,&#10;        &quot;ds18b20_2_temperature&quot; to &quot;23.71°C&quot;,&#10;        &quot;ds18b20_3_temperature&quot; to &quot;26.45°C&quot;,&#10;        &quot;ds18b20_4_temperature&quot; to &quot;25.56°C&quot;,&#10;        &quot;ds18b20_5_temperature&quot; to &quot;22.73°C&quot;,&#10;        // Última actualización&#10;        &quot;lastUpdated&quot; to &quot;Hace 1 min&quot;&#10;    )&#10;}&#10;&#10;fun createMockActuatorStates(): Map&lt;String, Boolean&gt; {&#10;    // All actuators OFF at start for mock&#10;    return mapOf(&#10;        &quot;water_pump_active&quot; to false,&#10;        &quot;fan1_active&quot; to false,&#10;        &quot;fan2_active&quot; to false,&#10;        &quot;light1_active&quot; to false,&#10;        &quot;light2_active&quot; to false,&#10;        &quot;light3_active&quot; to false,&#10;        &quot;heat_plate1_active&quot; to false&#10;    )&#10;}&#10;&#10;&#10;// Lista de topics MQTT válidos para este terrario&#10;private val VALID_MQTT_TOPICS = listOf(&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_04&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht22_02&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht22_03&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht22_04&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_01&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_02&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_05&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht22_01&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht11_01&quot;,&#10;    &quot;reptritrack/D85QPSadZhd8pXC0dpBwEUGD5gR2/esp01/sensores/pzem004&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_03&quot;&#10;)&#10;&#10;// Cuando recibas mensajes MQTT, filtra solo los que estén en VALID_MQTT_TOPICS&#10;// Por ejemplo, si tienes algo como:&#10;// val filteredMessages = allMessages.filter { it.topic in VALID_MQTT_TOPICS }&#10;&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun TerrariumDetailScreenPreview() {&#10;    ReptiTrackTheme {&#10;        // Use a test terrarium ID to activate mock mode in the Preview&#10;        TerrariumDetailScreen(terrariumId = &quot;placeholder_terrarium_id&quot;, onBackClick = {})&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.screens.terrariumdetail&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.animateContentSize&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.waldoz_x.reptitrack.ui.theme.ReptiTrackTheme&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import java.util.Locale&#10;import java.time.LocalTime // Import LocalTime&#10;import java.time.temporal.ChronoUnit // Import ChronoUnit&#10;import kotlinx.coroutines.delay // Import delay for LaunchedEffect&#10;import androidx.compose.runtime.LaunchedEffect // Import LaunchedEffect&#10;&#10;// Imports for using Painter and painterResource&#10;import androidx.compose.ui.graphics.painter.Painter&#10;import androidx.compose.ui.res.painterResource&#10;import com.waldoz_x.reptitrack.R // Make sure to import your R class to access drawables&#10;&#10;// Import for loading images asynchronously (Coil) - Not directly used for background images now, but kept for future use if needed&#10;import coil.compose.AsyncImage&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.foundation.layout.FlowRow&#10;import androidx.compose.foundation.layout.ExperimentalLayoutApi&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.foundation.BorderStroke // Import BorderStroke&#10;import androidx.compose.animation.animateColorAsState // Import animateColorAsState&#10;import androidx.compose.foundation.Canvas // Import Canvas for drawing circles&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.foundation.border&#10;import androidx.compose.ui.draw.shadow&#10;import com.waldoz_x.reptitrack.ui.components.Dht22SensorGroupCard&#10;import com.waldoz_x.reptitrack.ui.components.Ds18b20SensorGroupCard&#10;import com.waldoz_x.reptitrack.ui.components.OtherSensorsGroupCard&#10;import com.waldoz_x.reptitrack.ui.components.ActuatorControlCard&#10;import com.waldoz_x.reptitrack.ui.components.FoodDispenserCard&#10;import com.waldoz_x.reptitrack.ui.components.RainSystemCard&#10;import kotlin.random.Random&#10;&#10;// Definition of filter categories&#10;enum class TerrariumCategory(val displayName: String) {&#10;    ALL(&quot;Todo&quot;),&#10;    SENSORS(&quot;Sensores&quot;),&#10;    LIGHTS(&quot;Iluminación&quot;),&#10;    CLIMATE_WATER(&quot;Clima y Agua&quot;),&#10;    RAIN_SYSTEM(&quot;Sistema de Lluvia&quot;), // Nueva categoría&#10;    OTHER_SENSORS(&quot;Otros Sensores&quot;)&#10;}&#10;&#10;// This is the terrarium detail screen&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)&#10;@Composable&#10;fun TerrariumDetailScreen(&#10;    terrariumId: String,&#10;    onBackClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: TerrariumDetailViewModel = hiltViewModel()&#10;) {&#10;    // Observe terrarium state from the ViewModel&#10;    val terrariumState by viewModel.terrariumState.collectAsState()&#10;    val sensorData by viewModel.sensorData.collectAsState()&#10;    val actuatorStates by viewModel.actuatorStates.collectAsState()&#10;    val isMqttConnected by viewModel.isMqttConnected.collectAsState()&#10;&#10;    // State for category filter&#10;    var selectedCategory by remember { mutableStateOf(TerrariumCategory.ALL) }&#10;&#10;    // --- Logic to handle real vs. mock data ---&#10;    // If terrariumState is null, it means no real terrarium has been loaded (or we are in preview/mock mode)&#10;    val useMockData = terrariumState == null &amp;&amp; terrariumId == &quot;placeholder_terrarium_id&quot;&#10;&#10;    val currentTerrarium = if (useMockData) createMockTerrarium(terrariumId) else terrariumState&#10;    val currentSensorData = if (useMockData) createMockSensorData() else sensorData&#10;    // We use a local mutable state for mock actuators so they respond to the UI&#10;    var mockActuatorStates by remember { mutableStateOf(createMockActuatorStates()) }&#10;    val currentActuatorStates = if (useMockData) mockActuatorStates else actuatorStates&#10;    val currentMqttConnected = if (useMockData) true else isMqttConnected // Assume connected in mock&#10;&#10;    // Calcula el promedio de temperatura de los DHT22 (para &quot;Temperatura Actual&quot;)&#10;    val dhtTemperatures = currentSensorData.filterKeys { it.startsWith(&quot;dht22_&quot;) &amp;&amp; it.endsWith(&quot;_temperature&quot;) }&#10;        .mapNotNull { it.value.replace(&quot;°C&quot;, &quot;&quot;).toFloatOrNull() }&#10;    val averageDhtTemperature = if (dhtTemperatures.isNotEmpty()) {&#10;        String.format(Locale.getDefault(), &quot;%.1f°C&quot;, dhtTemperatures.average())&#10;    } else {&#10;        // Si no hay datos, muestra un valor aleatorio entre 28 y 30&#10;        String.format(Locale.getDefault(), &quot;%.1f°C&quot;, Random.nextDouble(28.0, 30.0))&#10;    }&#10;&#10;    // Calcula el promedio de temperatura de los DS18B20 (para &quot;Temp. Promedio&quot;)&#10;    val dsTemperatures = currentSensorData.filterKeys { it.startsWith(&quot;ds18b20_&quot;) &amp;&amp; it.endsWith(&quot;_temperature&quot;) }&#10;        .mapNotNull { it.value.replace(&quot;°C&quot;, &quot;&quot;).toFloatOrNull() }&#10;    val averageDsTemperature = if (dsTemperatures.isNotEmpty()) {&#10;        String.format(Locale.getDefault(), &quot;%.1f°C&quot;, dsTemperatures.average())&#10;    } else {&#10;        // Si no hay datos, muestra un valor aleatorio entre 24 y 28&#10;        String.format(Locale.getDefault(), &quot;%.1f°C&quot;, Random.nextDouble(24.0, 28.0))&#10;    }&#10;&#10;    // Calcula el promedio de humedad de los DHT22 (para &quot;Hum. Promedio&quot;)&#10;    val dhtHumidities = currentSensorData.filterKeys { it.startsWith(&quot;dht22_&quot;) &amp;&amp; it.endsWith(&quot;_humidity&quot;) }&#10;        .mapNotNull { it.value.replace(&quot;%&quot;, &quot;&quot;).toFloatOrNull() }&#10;    val averageHumidity = if (dhtHumidities.isNotEmpty()) {&#10;        String.format(Locale.getDefault(), &quot;%.1f%%&quot;, dhtHumidities.average())&#10;    } else {&#10;        // Si no hay datos, muestra un valor aleatorio entre 40 y 60&#10;        String.format(Locale.getDefault(), &quot;%.1f%%&quot;, Random.nextDouble(40.0, 60.0))&#10;    }&#10;&#10;    // &quot;Temperatura Actual&quot; ahora es el promedio de los DHT22&#10;    val mainTemperature = averageDhtTemperature&#10;&#10;    val lastUpdatedText = currentSensorData[&quot;lastUpdated&quot;] ?: &quot;N/A&quot;&#10;&#10;    // --- Logic for dynamic background (Day/Night) ---&#10;    var isDayTime by remember { mutableStateOf(isCurrentlyDayTime()) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            val now = LocalTime.now()&#10;            val nextMinuteStart = now.plusMinutes(1).truncatedTo(ChronoUnit.MINUTES)&#10;            val delayMillis = now.until(nextMinuteStart, ChronoUnit.MILLIS)&#10;            delay(delayMillis) // Wait until the start of the next minute&#10;            isDayTime = isCurrentlyDayTime()&#10;        }&#10;    }&#10;&#10;    // Background images (User needs to provide these in res/drawable)&#10;    val dayBackgroundImage = painterResource(id = R.drawable.jungle_background)&#10;    val nightBackgroundImage = painterResource(id = R.drawable.night_background_image)&#10;&#10;    val currentBackgroundImage = if (isDayTime) dayBackgroundImage else nightBackgroundImage&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    // Consider externalizing this string to strings.xml&#10;                    Text(&#10;                        text = &quot;Terrario: ${currentTerrarium?.name ?: terrariumId}&quot;,&#10;                        color = Color.Black // Changed text color to black&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBackClick) {&#10;                        // Consider externalizing this description to strings.xml&#10;                        Icon(&#10;                            Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Volver atrás&quot;,&#10;                            tint = Color.Black // Changed icon tint to black&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = { /* TODO: Implement more options if necessary */ }) {&#10;                        // Consider externalizing this description to strings.xml&#10;                        Icon(&#10;                            Icons.Default.Info,&#10;                            contentDescription = &quot;Más información&quot;,&#10;                            tint = Color.Black // Changed icon tint to black&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent) // Transparent TopAppBar&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        val scrollState = rememberScrollState()&#10;        Box(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues) // Apply Scaffold padding here&#10;        ) {&#10;            // 1. Background Image (bottom layer)&#10;            Image(&#10;                painter = currentBackgroundImage,&#10;                contentDescription = &quot;Fondo del terrario&quot;, // Consider externalizing&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentScale = ContentScale.Crop // Scale to fill, cropping if necessary&#10;            )&#10;&#10;            // Removed the intermediate transparent Card as per user request&#10;&#10;            // 3. Existing functional cards (top layer) - this is the current Column content&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .verticalScroll(scrollState)&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp), // Keep original padding for content&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Spacer(modifier = Modifier.height(8.dp)) // Top space&#10;&#10;                // Show a loading indicator only if we are NOT using mock data and the terrarium has not yet loaded&#10;                if (terrariumState == null &amp;&amp; !useMockData) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        // Consider externalizing this string to strings.xml&#10;                        Text(&#10;                            text = &quot;Cargando datos del terrario...&quot;,&#10;                            modifier = Modifier.padding(top = 80.dp),&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                } else {&#10;                    // Main screen content, visible when terrarium is loaded or in mock mode&#10;                    AnimatedVisibility(&#10;                        visible = currentTerrarium != null, // Visible if currentTerrarium has data (real or mock)&#10;                        enter = fadeIn(animationSpec = tween(durationMillis = 500)),&#10;                        exit = fadeOut(animationSpec = tween(durationMillis = 500))&#10;                    ) {&#10;                        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                            // General Summary Card with terrarium photo&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(bottom = 16.dp)&#10;                                    .animateContentSize(animationSpec = tween(durationMillis = 300)), // Size animation&#10;                                shape = RoundedCornerShape(24.dp), // Increased rounded corners&#10;                                elevation = CardDefaults.cardElevation(8.dp), // Higher elevation to make it stand out&#10;                                // Use a darker, transparent color for the primary container&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFF4A5C70).copy(alpha = 0.8f)) // Darker, transparent blue-grey&#10;                            ) {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(20.dp) // More internal padding&#10;                                ) {&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically,&#10;                                        horizontalArrangement = Arrangement.SpaceBetween&#10;                                    ) {&#10;                                        Column(modifier = Modifier.weight(1f)) {&#10;                                            // Consider externalizing this string to strings.xml&#10;                                            Text(&#10;                                                text = &quot;Gestión del Terrario&quot;,&#10;                                                style = MaterialTheme.typography.headlineSmall,&#10;                                                fontWeight = FontWeight.ExtraBold, // Bolder&#10;                                                color = Color.White // Text color white&#10;                                            )&#10;                                            Spacer(modifier = Modifier.height(6.dp)) // More space&#10;                                            // Consider externalizing this string to strings.xml&#10;                                            Text(&#10;                                                text = &quot;Monitorea y controla tu terrario en tiempo real.&quot;,&#10;                                                style = MaterialTheme.typography.bodyMedium,&#10;                                                color = Color.LightGray // Text color light gray&#10;                                            )&#10;                                        }&#10;                                        Spacer(modifier = Modifier.width(20.dp)) // More space&#10;                                        // Terrarium photo (ALWAYS FROM DRAWABLE)&#10;                                        Box(&#10;                                            modifier = Modifier&#10;                                                .size(120.dp) // Slightly larger size&#10;                                                .clip(RoundedCornerShape(24.dp)) // Ensures the image is clipped with rounded corners&#10;                                                .background(Color(0xFF81C784).copy(alpha = 0.2f)), // Subtle background that matches the theme&#10;                                            contentAlignment = Alignment.Center&#10;                                        ) {&#10;                                            // IMPORTANT: CHANGE 'R.drawable.ic_baseline_cloud_24' to your REAL terrarium image ID!&#10;                                            // This is a placeholder.&#10;                                            Image(&#10;                                                painter = painterResource(id = R.drawable.terrario), // &lt;-- Your image goes here!&#10;                                                contentDescription = &quot;Imagen del Terrario&quot;, // Consider externalizing&#10;                                                modifier = Modifier&#10;                                                    .fillMaxSize()&#10;                                                    .clip(RoundedCornerShape(24.dp)), // Clip image with rounded corners&#10;                                                contentScale = ContentScale.Crop // Scale to fill space&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                    Spacer(modifier = Modifier.height(20.dp)) // More space&#10;                                    Row(&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.Info, // Example icon, you can change it&#10;                                            contentDescription = &quot;Estado de conexión&quot;, // Consider externalizing&#10;                                            // Use theme colors for connection status&#10;                                            tint = if (currentMqttConnected) Color(0xFF4CAF50) else Color(0xFFD32F2F), // Green for connected, Red for disconnected&#10;                                            modifier = Modifier.size(28.dp) // Slightly larger icon&#10;                                        )&#10;                                        Spacer(modifier = Modifier.width(10.dp)) // More space&#10;                                        Text(&#10;                                            // Consider externalizing these strings to strings.xml&#10;                                            text = if (currentMqttConnected) &quot;Conectado al ESP32&quot; else &quot;Desconectado del ESP32&quot;,&#10;                                            style = MaterialTheme.typography.titleMedium, // More prominent text&#10;                                            fontWeight = FontWeight.SemiBold,&#10;                                            color = if (currentMqttConnected) Color(0xFF4CAF50) else Color(0xFFD32F2F)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // Prominent Temperature and Humidity Section (Improved)&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(bottom = 16.dp)&#10;                                    .animateContentSize(animationSpec = tween(durationMillis = 300)),&#10;                                shape = RoundedCornerShape(24.dp), // Increased rounded corners&#10;                                elevation = CardDefaults.cardElevation(4.dp), // Higher elevation&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFF2D3A4B).copy(alpha = 0.7f)) // Darker, transparent blue-grey&#10;                            ) {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(20.dp) // More padding&#10;                                ) {&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalAlignment = Alignment.CenterVertically,&#10;                                        horizontalArrangement = Arrangement.SpaceBetween&#10;                                    ) {&#10;                                        Column {&#10;                                            Text(&#10;                                                text = mainTemperature,&#10;                                                style = MaterialTheme.typography.displaySmall, // Larger text size&#10;                                                fontWeight = FontWeight.ExtraBold,&#10;                                                color = Color.White // Text color white&#10;                                            )&#10;                                            Text(&#10;                                                text = &quot;Temperatura Actual&quot;, // Consider externalizing&#10;                                                style = MaterialTheme.typography.bodyLarge, // Larger text&#10;                                                color = Color.LightGray // Text color light gray&#10;                                            )&#10;                                        }&#10;                                        Icon(&#10;                                            painter = getSensorIcon(&quot;temperature&quot;),&#10;                                            contentDescription = &quot;Temperatura&quot;, // Consider externalizing&#10;                                            tint = Color.White, // Icon color white&#10;                                            modifier = Modifier.size(64.dp) // Larger icon&#10;                                        )&#10;                                    }&#10;                                    Spacer(modifier = Modifier.height(16.dp)) // Space between main temperature and averages&#10;&#10;                                    Divider(modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp), color = Color.White.copy(alpha = 0.3f)) // Separator with transparency&#10;&#10;                                    Row(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        horizontalArrangement = Arrangement.SpaceAround,&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        // Average Humidity&#10;                                        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                            Icon(&#10;                                                painter = getSensorIcon(&quot;humidity&quot;),&#10;                                                contentDescription = &quot;Humedad Promedio&quot;, // Consider externalizing&#10;                                                tint = Color.White, // Icon color white&#10;                                                modifier = Modifier.size(40.dp)&#10;                                            )&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;                                            Text(&#10;                                                text = averageHumidity,&#10;                                                style = MaterialTheme.typography.titleLarge,&#10;                                                fontWeight = FontWeight.Bold,&#10;                                                color = Color.White // Text color white&#10;                                            )&#10;                                            Text(&#10;                                                text = &quot;Hum. Promedio&quot;, // Consider externalizing&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                color = Color.LightGray // Text color light gray&#10;                                            )&#10;                                        }&#10;&#10;                                        // Average Temperature (if different from main, or as a second indicator)&#10;                                        // You could decide to show it only if it's significantly different from mainTemperature&#10;                                        // Or simply as a &quot;general average&quot; vs &quot;current&quot;&#10;                                        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                            Icon(&#10;                                                painter = getSensorIcon(&quot;temperature&quot;),&#10;                                                contentDescription = &quot;Temperatura Promedio&quot;, // Consider externalizing&#10;                                                tint = Color.White, // Icon color white&#10;                                                modifier = Modifier.size(40.dp)&#10;                                            )&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;                                            Text(&#10;                                                text = averageDsTemperature,&#10;                                                style = MaterialTheme.typography.titleLarge,&#10;                                                fontWeight = FontWeight.Bold,&#10;                                                color = Color.White // Text color white&#10;                                            )&#10;                                            Text(&#10;                                                text = &quot;Temp. Promedio&quot;, // Consider externalizing&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                color = Color.LightGray // Text color light gray&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // Last Updated Card (New addition for better visibility)&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(bottom = 16.dp)&#10;                                    .animateContentSize(animationSpec = tween(durationMillis = 300)),&#10;                                shape = RoundedCornerShape(16.dp),&#10;                                elevation = CardDefaults.cardElevation(2.dp),&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFF607D8B).copy(alpha = 0.6f)) // Lighter transparent blue-grey&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically,&#10;                                    horizontalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Icon(&#10;                                        painter = painterResource(id = R.drawable.outline_mode_fan_24), // Using a clock icon&#10;                                        contentDescription = &quot;Última Actualización&quot;,&#10;                                        tint = Color.White,&#10;                                        modifier = Modifier.size(20.dp)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&#10;                                        text = &quot;Última Actualización: $lastUpdatedText&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        fontWeight = FontWeight.SemiBold,&#10;                                        color = Color.White,&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;&#10;                            // Filter Section&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            // Consider externalizing this string to strings.xml&#10;                            Text(&#10;                                text = &quot;Filtrar por:&quot;,&#10;                                style = MaterialTheme.typography.titleSmall,&#10;                                color = Color.White, // Text color white&#10;                                modifier = Modifier.align(Alignment.Start).padding(start = 4.dp, bottom = 4.dp)&#10;                            )&#10;                            FlowRow(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                TerrariumCategory.values().forEach { category -&gt;&#10;                                    CategoryFilterChip(&#10;                                        category = category,&#10;                                        selected = selectedCategory == category,&#10;                                        onClick = { selectedCategory = category }&#10;                                    )&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                            // --- Sensor Data Display (Refactored) ---&#10;                            // DHT22 Sensors Group&#10;                            AnimatedVisibility(&#10;                                visible = selectedCategory == TerrariumCategory.ALL || selectedCategory == TerrariumCategory.SENSORS || selectedCategory == TerrariumCategory.CLIMATE_WATER,&#10;                                enter = fadeIn(animationSpec = tween(durationMillis = 300)),&#10;                                exit = fadeOut(animationSpec = tween(durationMillis = 300))&#10;                            ) {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Temperatura Hambiente&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    // Cuadrícula 2x2 para los sensores DHT22&#10;                                    Column(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                    ) {&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.SpaceEvenly&#10;                                        ) {&#10;                                            Dht22SensorGroupCard(sensorNumber = 1, sensorData = currentSensorData)&#10;                                            Dht22SensorGroupCard(sensorNumber = 2, sensorData = currentSensorData)&#10;                                        }&#10;                                        Row(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.SpaceEvenly&#10;                                        ) {&#10;                                            Dht22SensorGroupCard(sensorNumber = 3, sensorData = currentSensorData)&#10;                                            Dht22SensorGroupCard(sensorNumber = 4, sensorData = currentSensorData)&#10;                                        }&#10;                                    }&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;                                }&#10;                            }&#10;&#10;                            // DS18B20 Sensors Group y Otros Sensores&#10;                            AnimatedVisibility(&#10;                                visible = selectedCategory == TerrariumCategory.ALL || selectedCategory == TerrariumCategory.SENSORS || selectedCategory == TerrariumCategory.OTHER_SENSORS,&#10;                                enter = fadeIn(animationSpec = tween(durationMillis = 300)),&#10;                                exit = fadeOut(animationSpec = tween(durationMillis = 300))&#10;                            ) {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Temperatura del Suelo&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    Ds18b20SensorGroupCard(sensorData = currentSensorData)&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                                    Text(&#10;                                        text = &quot;Otros Sensores&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    // Solo muestra la potencia del sensor pzem004&#10;                                    val powerValue = currentSensorData[&quot;pzem_1_power&quot;] ?: &quot;N/A&quot;&#10;                                    Row(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(vertical = 8.dp),&#10;                                        horizontalArrangement = Arrangement.Center,&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Icon(&#10;                                            painter = getSensorIcon(&quot;power&quot;),&#10;                                            contentDescription = &quot;Potencia&quot;,&#10;                                            tint = Color.White,&#10;                                            modifier = Modifier.size(32.dp)&#10;                                        )&#10;                                        Spacer(modifier = Modifier.width(8.dp))&#10;                                        Text(&#10;                                            text = powerValue,&#10;                                            style = MaterialTheme.typography.titleLarge,&#10;                                            color = Color.White&#10;                                        )&#10;                                    }&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;                                }&#10;                            }&#10;&#10;                            // Actuator Controls&#10;                            AnimatedVisibility(&#10;                                visible = selectedCategory == TerrariumCategory.ALL || selectedCategory == TerrariumCategory.LIGHTS || selectedCategory == TerrariumCategory.CLIMATE_WATER,&#10;                                enter = fadeIn(animationSpec = tween(durationMillis = 300)),&#10;                                exit = fadeOut(animationSpec = tween(durationMillis = 300))&#10;                            ) {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Controles de Actuadores&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    // Cuadrícula de actuadores en 2 columnas&#10;                                    val actuatorList = currentActuatorStates&#10;                                        .filterKeys { it != &quot;water_pump_active&quot; }&#10;                                        .toList()&#10;                                    Column(&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                    ) {&#10;                                        actuatorList.chunked(2).forEach { rowActuators -&gt;&#10;                                            Row(&#10;                                                modifier = Modifier.fillMaxWidth(),&#10;                                                horizontalArrangement = Arrangement.SpaceEvenly&#10;                                            ) {&#10;                                                rowActuators.forEach { (key, isActive) -&gt;&#10;                                                    ActuatorControlCard(&#10;                                                        actuatorKey = key,&#10;                                                        isActive = isActive,&#10;                                                        onToggle = { newState -&gt;&#10;                                                            if (useMockData) {&#10;                                                                mockActuatorStates = mockActuatorStates.toMutableMap().apply {&#10;                                                                    this[key] = newState&#10;                                                                }&#10;                                                            } else {&#10;                                                                currentTerrarium?.let { terrarium -&gt;&#10;                                                                    viewModel.toggleActuator(terrarium.id, key, newState)&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // Nueva sección destacada para el dispensador de comida&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(bottom = 16.dp)&#10;                                    .animateContentSize(animationSpec = tween(durationMillis = 300)),&#10;                                shape = RoundedCornerShape(24.dp),&#10;                                elevation = CardDefaults.cardElevation(8.dp),&#10;                                colors = CardDefaults.cardColors(containerColor = Color(0xFFFFC107).copy(alpha = 0.8f)) // Color amarillo para destacar&#10;                            ) {&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(20.dp),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally&#10;                                ) {&#10;                                    FoodDispenserCard(&#10;                                        isActive = currentActuatorStates[&quot;food_dispenser_active&quot;] ?: false,&#10;                                        loads = currentSensorData[&quot;food_dispenser_loads&quot;]?.toIntOrNull() ?: 0,&#10;                                        onDispense = { newState -&gt;&#10;                                            if (useMockData) {&#10;                                                mockActuatorStates = mockActuatorStates.toMutableMap().apply {&#10;                                                    this[&quot;food_dispenser_active&quot;] = newState&#10;                                                }&#10;                                            } else {&#10;                                                currentTerrarium?.let { terrarium -&gt;&#10;                                                    viewModel.toggleActuator(terrarium.id, &quot;food_dispenser_active&quot;, newState)&#10;                                                }&#10;                                            }&#10;                                        },&#10;                                        onRecharge = {&#10;                                            // Aquí puedes poner la lógica para recargar el dispensador.&#10;                                            // Por ejemplo, podrías mostrar un diálogo, enviar un comando, etc.&#10;                                            // Si no tienes lógica aún, puedes dejarlo vacío.&#10;                                        }&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            // Sistema de Lluvia (Rain System)&#10;                            AnimatedVisibility(&#10;                                visible = selectedCategory == TerrariumCategory.ALL || selectedCategory == TerrariumCategory.RAIN_SYSTEM,&#10;                                enter = fadeIn(animationSpec = tween(durationMillis = 300)),&#10;                                exit = fadeOut(animationSpec = tween(durationMillis = 300))&#10;                            ) {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Sistema de Lluvia&quot;,&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        color = Color.White,&#10;                                        modifier = Modifier.padding(vertical = 8.dp)&#10;                                    )&#10;                                    RainSystemCard(&#10;                                        isActive = currentActuatorStates[&quot;water_pump_active&quot;] ?: false,&#10;                                        waterDistance = currentSensorData[&quot;hc_sr04_1_distance&quot;]?.replace(&quot; cm&quot;, &quot;&quot;)?.toFloatOrNull(),&#10;                                        onToggle = { newState -&gt;&#10;                                            if (useMockData) {&#10;                                                mockActuatorStates = mockActuatorStates.toMutableMap().apply {&#10;                                                    this[&quot;water_pump_active&quot;] = newState&#10;                                                }&#10;                                            } else {&#10;                                                currentTerrarium?.let { terrarium -&gt;&#10;                                                    viewModel.toggleActuator(terrarium.id, &quot;water_pump_active&quot;, newState)&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;// Mejoras en los filtros: iconos y colores por categoría&#10;@Composable&#10;fun CategoryFilterChip(&#10;    category: TerrariumCategory,&#10;    selected: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    val icon: Painter = when (category) {&#10;        TerrariumCategory.ALL -&gt; painterResource(id = R.drawable.ic_baseline_cloud_24)&#10;        TerrariumCategory.SENSORS -&gt; painterResource(id = R.drawable.ic_baseline_thermostat_24)&#10;        TerrariumCategory.LIGHTS -&gt; painterResource(id = R.drawable.baseline_lightbulb_24)&#10;        TerrariumCategory.CLIMATE_WATER -&gt; painterResource(id = R.drawable.ic_outline_water_pump_24)&#10;        TerrariumCategory.RAIN_SYSTEM -&gt; painterResource(id = R.drawable.ic_outline_water_pump_24) // Usa el mismo ícono o uno diferente si tienes&#10;        TerrariumCategory.OTHER_SENSORS -&gt; painterResource(id = R.drawable.ic_outline_settings_power_24)&#10;    }&#10;    val chipColor = when (category) {&#10;        TerrariumCategory.ALL -&gt; Color(0xFF607D8B)&#10;        TerrariumCategory.SENSORS -&gt; Color(0xFF90CAF9)&#10;        TerrariumCategory.LIGHTS -&gt; Color(0xFFFFF176)&#10;        TerrariumCategory.CLIMATE_WATER -&gt; Color(0xFF80DEEA)&#10;        TerrariumCategory.RAIN_SYSTEM -&gt; Color(0xFF4FC3F7) // Azul para el sistema de lluvia&#10;        TerrariumCategory.OTHER_SENSORS -&gt; Color(0xFFA5D6A7)&#10;    }&#10;&#10;    // Animaciones para el borde y sombra&#10;    val borderWidth by animateDpAsState(targetValue = if (selected) 3.dp else 1.dp)&#10;    val borderColor by animateColorAsState(targetValue = if (selected) chipColor else chipColor.copy(alpha = 0.5f))&#10;    val shadowElevation by animateDpAsState(targetValue = if (selected) 8.dp else 0.dp)&#10;    val backgroundColor by animateColorAsState(targetValue = if (selected) chipColor.copy(alpha = 0.95f) else chipColor.copy(alpha = 0.7f))&#10;&#10;    FilterChip(&#10;        selected = selected,&#10;        onClick = onClick,&#10;        label = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Icon(painter = icon, contentDescription = null, tint = Color.White, modifier = Modifier.size(18.dp))&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;                Text(category.displayName, color = Color.White)&#10;            }&#10;        },&#10;        modifier = Modifier&#10;            .shadow(shadowElevation, RoundedCornerShape(50))&#10;            .border(borderWidth, borderColor, RoundedCornerShape(50)),&#10;        colors = FilterChipDefaults.filterChipColors(&#10;            selectedContainerColor = backgroundColor,&#10;            selectedLabelColor = Color.White,&#10;            containerColor = backgroundColor,&#10;            labelColor = Color.White&#10;        ),&#10;        border = null // El borde se maneja por el modifier&#10;    )&#10;}&#10;&#10;&#10;// Helper function to get health color based on value and type&#10;@Composable&#10;fun getHealthColor(value: Float?, sensorType: String): Color {&#10;    if (value == null) return Color.LightGray.copy(alpha = 0.6f) // For N/A values&#10;&#10;    return when (sensorType) {&#10;        &quot;temperature&quot; -&gt; {&#10;            when {&#10;                value &lt; 20.0f -&gt; Color(0xFFADD8E6) // Light Blue (Cold)&#10;                value &gt; 30.0f -&gt; Color(0xFFFFA07A) // Light Salmon (Hot)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        &quot;humidity&quot; -&gt; {&#10;            when {&#10;                value &lt; 50.0f -&gt; Color(0xFFFFA07A) // Light Salmon (Dry)&#10;                value &gt; 80.0f -&gt; Color(0xFFADD8E6) // Light Blue (Humid)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        &quot;distance&quot; -&gt; {&#10;            when {&#10;                value &lt; 10.0f -&gt; Color(0xFFFFA07A) // Light Salmon (Too close)&#10;                value &gt; 50.0f -&gt; Color(0xFFADD8E6) // Light Blue (Too far)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        &quot;power&quot; -&gt; {&#10;            when {&#10;                value &gt; 100.0f -&gt; Color(0xFFFFA07A) // Light Salmon (High power)&#10;                else -&gt; Color(0xFF90EE90) // Light Green (Normal)&#10;            }&#10;        }&#10;        else -&gt; Color.White // Default&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun getSensorIcon(sensorType: String): Painter {&#10;    return when (sensorType) {&#10;        &quot;temperature&quot; -&gt; painterResource(id = R.drawable.ic_baseline_thermostat_24) // Placeholder, replace with actual icon&#10;        &quot;humidity&quot; -&gt; painterResource(id = R.drawable.ic_outline_humidity_high_24) // Placeholder, replace with actual icon&#10;        &quot;distance&quot; -&gt; painterResource(id = R.drawable.ic_outline_distance_24) // Placeholder, replace with actual icon&#10;        &quot;power&quot; -&gt; painterResource(id = R.drawable.ic_outline_settings_power_24) // Placeholder, replace with actual icon&#10;        else -&gt; painterResource(id = R.drawable.ic_baseline_cloud_24) // Generic placeholder&#10;    }&#10;}&#10;&#10;// Helper function to determine if it's day or night (adjust hours as needed)&#10;fun isCurrentlyDayTime(): Boolean {&#10;    val currentHour = LocalTime.now().hour&#10;    return currentHour in 6..19 // Between 6 AM and 7 PM&#10;}&#10;&#10;// --- Mock Data for Previews ---&#10;fun createMockTerrarium(id: String): Terrarium {&#10;    return Terrarium(&#10;        id = id,&#10;        name = &quot;Terrario de Prueba&quot;,&#10;        description = &quot;Este es un terrario de prueba para desarrollo de UI.&quot;,&#10;        dht22_1_temperature = 25.0f,&#10;        dht22_1_humidity = 70.0f,&#10;        dht22_2_temperature = 26.5f,&#10;        dht22_2_humidity = 65.0f,&#10;        dht22_3_temperature = 19.0f, // Example of low temp&#10;        dht22_3_humidity = 85.0f, // Example of high humidity&#10;        dht22_4_temperature = 32.0f, // Example of high temp&#10;        dht22_4_humidity = 45.0f, // Example of low humidity&#10;        ds18b20_1_temperature = 23.0f,&#10;        ds18b20_2_temperature = 22.5f,&#10;        ds18b20_3_temperature = 24.5f,&#10;        ds18b20_4_temperature = 23.8f,&#10;        ds18b20_5_temperature = 22.0f,&#10;        hc_sr04_1_distance = 5.0f, // Example of low distance&#10;        pzem_1_power = 120.0f, // Example of high power&#10;        // All actuators OFF at start for mock&#10;        waterPumpActive = false,&#10;        fan1Active = false,&#10;        fan2Active = false,&#10;        light1Active = false,&#10;        light2Active = false,&#10;        light3Active = false,&#10;        heatPlate1Active = false,&#10;        lastUpdated = System.currentTimeMillis()&#10;    )&#10;}&#10;&#10;fun createMockSensorData(): Map&lt;String, String&gt; {&#10;    // Mapea los topics y payloads reales a las claves que usa tu UI&#10;    return mapOf(&#10;        // DHT11&#10;        &quot;dht11_1_humidity&quot; to &quot;65.88%&quot;,&#10;        &quot;dht11_1_temperature&quot; to &quot;21.69°C&quot;,&#10;        // DHT22&#10;        &quot;dht22_1_humidity&quot; to &quot;48.66%&quot;,&#10;        &quot;dht22_1_temperature&quot; to &quot;25.11°C&quot;,&#10;        &quot;dht22_2_humidity&quot; to &quot;50.51%&quot;,&#10;        &quot;dht22_2_temperature&quot; to &quot;20.33°C&quot;,&#10;        &quot;dht22_3_humidity&quot; to &quot;55.40%&quot;,&#10;        &quot;dht22_3_temperature&quot; to &quot;27.16°C&quot;,&#10;        &quot;dht22_4_humidity&quot; to &quot;64.87%&quot;,&#10;        &quot;dht22_4_temperature&quot; to &quot;24.49°C&quot;,&#10;        // DS18B20&#10;        &quot;ds18b20_1_temperature&quot; to &quot;34.40°C&quot;,&#10;        &quot;ds18b20_2_temperature&quot; to &quot;23.71°C&quot;,&#10;        &quot;ds18b20_3_temperature&quot; to &quot;26.45°C&quot;,&#10;        &quot;ds18b20_4_temperature&quot; to &quot;25.56°C&quot;,&#10;        &quot;ds18b20_5_temperature&quot; to &quot;22.73°C&quot;,&#10;        // Última actualización&#10;        &quot;lastUpdated&quot; to &quot;Hace 1 min&quot;&#10;    )&#10;}&#10;&#10;fun createMockActuatorStates(): Map&lt;String, Boolean&gt; {&#10;    // All actuators OFF at start for mock&#10;    return mapOf(&#10;        &quot;water_pump_active&quot; to false,&#10;        &quot;fan1_active&quot; to false,&#10;        &quot;fan2_active&quot; to false,&#10;        &quot;light1_active&quot; to false,&#10;        &quot;light2_active&quot; to false,&#10;        &quot;light3_active&quot; to false,&#10;        &quot;heat_plate1_active&quot; to false&#10;    )&#10;}&#10;&#10;&#10;// Lista de topics MQTT válidos para este terrario&#10;private val VALID_MQTT_TOPICS = listOf(&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_04&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht22_02&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht22_03&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht22_04&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_01&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_02&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_05&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht22_01&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/dht11_01&quot;,&#10;    &quot;reptritrack/D85QPSadZhd8pXC0dpBwEUGD5gR2/esp01/sensores/pzem004&quot;,&#10;    &quot;reptritrack/Ipzro9ETmRX9moHzQ0QNXv06SBy1/esp02/sensores/ds18b20_03&quot;&#10;)&#10;&#10;// Cuando recibas mensajes MQTT, filtra solo los que estén en VALID_MQTT_TOPICS&#10;// Por ejemplo, si tienes algo como:&#10;// val filteredMessages = allMessages.filter { it.topic in VALID_MQTT_TOPICS }&#10;&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun TerrariumDetailScreenPreview() {&#10;    ReptiTrackTheme {&#10;        // Use a test terrarium ID to activate mock mode in the Preview&#10;        TerrariumDetailScreen(terrariumId = &quot;placeholder_terrarium_id&quot;, onBackClick = {})&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/screens/terrariumdetail/TerrariumDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/waldoz_x/reptitrack/ui/screens/terrariumdetail/TerrariumDetailViewModel.kt" />
              <option name="originalContent" value="package com.waldoz_x.reptitrack.ui.screens.terrariumdetail&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.SavedStateHandle&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.waldoz_x.reptitrack.data.source.remote.HiveMqttClient&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import com.waldoz_x.reptitrack.domain.repository.TerrariumRepository&#10;import com.waldoz_x.reptitrack.navigation.Destinations&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Dispatchers // Importar Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext // Importar withContext&#10;import java.util.Date&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import kotlin.random.Random&#10;&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class TerrariumDetailViewModel @Inject constructor(&#10;    private val terrariumRepository: TerrariumRepository,&#10;    private val hiveMqttClient: HiveMqttClient,&#10;    savedStateHandle: SavedStateHandle&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;TerrariumDetailViewModel&quot;&#10;&#10;    private val _terrariumState = MutableStateFlow&lt;Terrarium?&gt;(null)&#10;    val terrariumState: StateFlow&lt;Terrarium?&gt; = _terrariumState.asStateFlow()&#10;&#10;    private val _sensorData = MutableStateFlow&lt;Map&lt;String, String&gt;&gt;(emptyMap())&#10;    val sensorData: StateFlow&lt;Map&lt;String, String&gt;&gt; = _sensorData.asStateFlow()&#10;&#10;    private val _actuatorStates = MutableStateFlow&lt;Map&lt;String, Boolean&gt;&gt;(emptyMap())&#10;    val actuatorStates: StateFlow&lt;Map&lt;String, Boolean&gt;&gt; = _actuatorStates.asStateFlow()&#10;&#10;    val isMqttConnected: StateFlow&lt;Boolean&gt; = hiveMqttClient.isConnected&#10;&#10;    private val terrariumId: String = savedStateHandle.get&lt;String&gt;(Destinations.TERRARIUM_ID_ARG)&#10;        ?: throw IllegalStateException(&quot;Terrarium ID no encontrado en los argumentos de navegación.&quot;)&#10;&#10;    // Usa el userId correcto para que coincida con los topics MQTT reales&#10;    private val userId: String = &quot;Ipzro9ETmRX9moHzQ0QNXv06SBy1&quot;&#10;&#10;    init {&#10;        Log.d(TAG, &quot;ViewModel inicializado para Terrario ID: $terrariumId&quot;)&#10;        startSimulatedSensorUpdates() // &lt;-- Siempre simular datos&#10;        loadTerrariumData()&#10;        observeMqttMessages()&#10;        observeMqttConnection()&#10;    }&#10;&#10;    // Simula y actualiza datos de sensores cada 2 segundos (excepto pzem)&#10;    private fun startSimulatedSensorUpdates() {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            while (true) {&#10;                fun tempDht() = String.format(&quot;%.2f°C&quot;, Random.nextDouble(28.0, 30.0))&#10;                fun humDht() = String.format(&quot;%.2f%%&quot;, Random.nextDouble(40.0, 60.0))&#10;                fun tempDsb() = String.format(&quot;%.2f°C&quot;, Random.nextDouble(24.0, 28.0))&#10;                val current = _sensorData.value.toMutableMap()&#10;                // DHT11&#10;                current[&quot;dht11_1_humidity&quot;] = humDht()&#10;                current[&quot;dht11_1_temperature&quot;] = tempDht()&#10;                // DHT22&#10;                current[&quot;dht22_1_humidity&quot;] = humDht()&#10;                current[&quot;dht22_1_temperature&quot;] = tempDht()&#10;                current[&quot;dht22_2_humidity&quot;] = humDht()&#10;                current[&quot;dht22_2_temperature&quot;] = tempDht()&#10;                current[&quot;dht22_3_humidity&quot;] = humDht()&#10;                current[&quot;dht22_3_temperature&quot;] = tempDht()&#10;                current[&quot;dht22_4_humidity&quot;] = humDht()&#10;                current[&quot;dht22_4_temperature&quot;] = tempDht()&#10;                // DS18B20&#10;                current[&quot;ds18b20_1_temperature&quot;] = tempDsb()&#10;                current[&quot;ds18b20_2_temperature&quot;] = tempDsb()&#10;                current[&quot;ds18b20_3_temperature&quot;] = tempDsb()&#10;                current[&quot;ds18b20_4_temperature&quot;] = tempDsb()&#10;                current[&quot;ds18b20_5_temperature&quot;] = tempDsb()&#10;                // Última actualización&#10;                current[&quot;lastUpdated&quot;] = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date()) + &quot; (Simulado)&quot;&#10;                // pzem_1_power NO se toca aquí, solo por MQTT real&#10;                _sensorData.value = current&#10;                kotlinx.coroutines.delay(2000)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadTerrariumData() {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            terrariumRepository.getTerrariumById(&#10;                userId = userId,&#10;                id = terrariumId&#10;            ).collect { terrarium -&gt;&#10;                _terrariumState.value = terrarium&#10;                terrarium?.let {&#10;                    _actuatorStates.value = mapOf(&#10;                        &quot;water_pump_active&quot; to it.waterPumpActive,&#10;                        &quot;fan1_active&quot; to it.fan1Active,&#10;                        &quot;fan2_active&quot; to it.fan2Active,&#10;                        &quot;light1_active&quot; to it.light1Active,&#10;                        &quot;light2_active&quot; to it.light2Active,&#10;                        &quot;light3_active&quot; to it.light3Active,&#10;                        &quot;heat_plate1_active&quot; to it.heatPlate1Active&#10;                    )&#10;&#10;                    val currentSensorData = mutableMapOf&lt;String, String&gt;()&#10;&#10;                    it.dht22_1_temperature?.let { temp -&gt; currentSensorData[&quot;dht22_1_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.dht22_1_humidity?.let { hum -&gt; currentSensorData[&quot;dht22_1_humidity&quot;] = &quot;${hum}%&quot; }&#10;                    it.dht22_2_temperature?.let { temp -&gt; currentSensorData[&quot;dht22_2_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.dht22_2_humidity?.let { hum -&gt; currentSensorData[&quot;dht22_2_humidity&quot;] = &quot;${hum}%&quot; }&#10;                    it.dht22_3_temperature?.let { temp -&gt; currentSensorData[&quot;dht22_3_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.dht22_3_humidity?.let { hum -&gt; currentSensorData[&quot;dht22_3_humidity&quot;] = &quot;${hum}%&quot; }&#10;                    it.dht22_4_temperature?.let { temp -&gt; currentSensorData[&quot;dht22_4_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.dht22_4_humidity?.let { hum -&gt; currentSensorData[&quot;dht22_4_humidity&quot;] = &quot;${hum}%&quot; }&#10;&#10;                    it.ds18b20_1_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_1_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.ds18b20_2_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_2_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.ds18b20_3_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_3_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.ds18b20_4_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_4_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.ds18b20_5_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_5_temperature&quot;] = &quot;${temp}°C&quot; }&#10;&#10;                    it.hc_sr04_1_distance?.let { dist -&gt; currentSensorData[&quot;hc_sr04_1_distance&quot;] = &quot;${dist} cm&quot; }&#10;                    it.pzem_1_power?.let { power -&gt; currentSensorData[&quot;pzem_1_power&quot;] = &quot;${power} W&quot; }&#10;&#10;                    currentSensorData[&quot;lastUpdated&quot;] = it.lastUpdated.let { timestamp -&gt;&#10;                        if (timestamp != null &amp;&amp; timestamp &gt; 0) {&#10;                            val date = Date(timestamp)&#10;                            val sdf = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault())&#10;                            sdf.format(date) + &quot; (hace &quot; + formatTimeAgo(timestamp) + &quot;)&quot;&#10;                        } else {&#10;                            &quot;N/A&quot;&#10;                        }&#10;                    }&#10;&#10;                    _sensorData.value = currentSensorData&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun formatTimeAgo(timestamp: Long): String {&#10;        val now = System.currentTimeMillis()&#10;        val diff = now - timestamp&#10;&#10;        val seconds = diff / 1000&#10;        val minutes = seconds / 60&#10;        val hours = minutes / 60&#10;        val days = hours / 24&#10;&#10;        return when {&#10;            seconds &lt; 60 -&gt; &quot;$seconds s&quot;&#10;            minutes &lt; 60 -&gt; &quot;$minutes min&quot;&#10;            hours &lt; 24 -&gt; &quot;$hours h&quot;&#10;            else -&gt; &quot;$days d&quot;&#10;        }&#10;    }&#10;&#10;    private fun observeMqttMessages() {&#10;        viewModelScope.launch {&#10;            combine(hiveMqttClient.isConnected, hiveMqttClient.receivedMessages) { isConnected, messagePair -&gt;&#10;                if (isConnected &amp;&amp; messagePair != null) {&#10;                    messagePair&#10;                } else {&#10;                    null&#10;                }&#10;            }.collect { messagePair -&gt;&#10;                messagePair?.let { (topic, payload) -&gt;&#10;                    Log.d(TAG, &quot;Mensaje MQTT recibido en ViewModel: $topic -&gt; $payload&quot;)&#10;                    // El procesamiento del mensaje puede ser ligero, pero si se vuelve complejo,&#10;                    // considera moverlo a un Dispatchers.Default o Dispatchers.IO&#10;                    processMqttMessage(topic, payload)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun observeMqttConnection() {&#10;        viewModelScope.launch {&#10;            hiveMqttClient.isConnected.collect { isConnected -&gt;&#10;                if (isConnected) {&#10;                    Log.d(TAG, &quot;Conexión MQTT establecida, suscribiendo a tópicos del usuario: $userId&quot;)&#10;                    withContext(Dispatchers.IO) {&#10;                        // Suscríbete al topic real de tus sensores&#10;                        hiveMqttClient.subscribeToTopic(&quot;reptritrack/$userId/esp02/sensores/#&quot;)&#10;                    }&#10;                } else {&#10;                    Log.d(TAG, &quot;Conexión MQTT perdida para usuario: $userId&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun processMqttMessage(topic: String, payload: String) {&#10;        // Solo para el sensor de potencia, procesa únicamente la potencia&#10;        if (topic == &quot;reptritrack/D85QPSadZhd8pXC0dpBwEUGD5gR2/esp01/sensores/pzem004&quot;) {&#10;            try {&#10;                val map = payload.trim()&#10;                    .removePrefix(&quot;{&quot;).removeSuffix(&quot;}&quot;)&#10;                    .split(&quot;,&quot;)&#10;                    .map { it.split(&quot;:&quot;) }&#10;                    .associate { it[0].replace(&quot;\&quot;&quot;, &quot;&quot;).trim() to it[1].replace(&quot;\&quot;&quot;, &quot;&quot;).trim() }&#10;&#10;                val updated = _sensorData.value.toMutableMap()&#10;                map[&quot;potencia&quot;]?.let { potencia -&gt;&#10;                    updated[&quot;pzem_1_power&quot;] = &quot;$potencia W&quot;&#10;                }&#10;                updated[&quot;lastUpdated&quot;] = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date()) + &quot; (hace &quot; + formatTimeAgo(System.currentTimeMillis()) + &quot;)&quot;&#10;                _sensorData.value = updated&#10;                Log.d(TAG, &quot;Sensor pzem004 actualizado solo con potencia: $payload&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error al parsear JSON de pzem004: $payload&quot;, e)&#10;            }&#10;            return&#10;        }&#10;&#10;        // Para todos los demás sensores, deja el comportamiento tal cual&#10;        val parts = topic.split(&quot;/&quot;)&#10;        if (parts.size &gt;= 5 &amp;&amp; parts[0] == &quot;reptritrack&quot; &amp;&amp; parts[2] == &quot;esp02&quot; &amp;&amp; parts[3] == &quot;sensores&quot;) {&#10;            val sensorKeyRaw = parts[4]&#10;            val sensorKeyNormalized = sensorKeyRaw&#10;                .replace(Regex(&quot;_(0*)([1-9][0-9]*)$&quot;), &quot;_$2&quot;)&#10;&#10;            if (payload.trim().startsWith(&quot;{&quot;) &amp;&amp; payload.trim().endsWith(&quot;}&quot;)) {&#10;                try {&#10;                    val map = payload.trim()&#10;                        .removePrefix(&quot;{&quot;).removeSuffix(&quot;}&quot;)&#10;                        .split(&quot;,&quot;)&#10;                        .map { it.split(&quot;:&quot;) }&#10;                        .associate { it[0].replace(&quot;\&quot;&quot;, &quot;&quot;).trim() to it[1].replace(&quot;\&quot;&quot;, &quot;&quot;).trim() }&#10;&#10;                    val updated = _sensorData.value.toMutableMap()&#10;                    map.forEach { (k, v) -&gt;&#10;                        val key = when (k.lowercase()) {&#10;                            &quot;temperature&quot;, &quot;temperatura&quot; -&gt; &quot;${sensorKeyNormalized}_temperature&quot;&#10;                            &quot;humidity&quot;, &quot;humedad&quot; -&gt; &quot;${sensorKeyNormalized}_humidity&quot;&#10;                            &quot;distance&quot;, &quot;distancia&quot; -&gt; &quot;${sensorKeyNormalized}_distance&quot;&#10;                            &quot;power&quot;, &quot;potencia&quot; -&gt; &quot;${sensorKeyNormalized}_power&quot;&#10;                            else -&gt; &quot;${sensorKeyNormalized}_$k&quot;&#10;                        }&#10;                        val value = when (k.lowercase()) {&#10;                            &quot;temperature&quot;, &quot;temperatura&quot; -&gt; &quot;$v°C&quot;&#10;                            &quot;humidity&quot;, &quot;humedad&quot; -&gt; &quot;$v%&quot;&#10;                            &quot;distance&quot;, &quot;distancia&quot; -&gt; &quot;$v cm&quot;&#10;                            &quot;power&quot;, &quot;potencia&quot; -&gt; &quot;$v W&quot;&#10;                            else -&gt; v&#10;                        }&#10;                        updated[key] = value&#10;                    }&#10;                    updated[&quot;lastUpdated&quot;] = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date()) + &quot; (hace &quot; + formatTimeAgo(System.currentTimeMillis()) + &quot;)&quot;&#10;                    _sensorData.value = updated&#10;                    Log.d(TAG, &quot;Sensor $sensorKeyNormalized actualizado con JSON: $payload&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error al parsear JSON de sensor: $payload&quot;, e)&#10;                }&#10;            } else {&#10;                val updated = _sensorData.value.toMutableMap()&#10;                when {&#10;                    sensorKeyNormalized.startsWith(&quot;dht22_&quot;) -&gt; {&#10;                        if (payload.contains(&quot;%&quot;)) {&#10;                            updated[&quot;${sensorKeyNormalized}_humidity&quot;] = payload&#10;                        } else if (payload.contains(&quot;°C&quot;)) {&#10;                            updated[&quot;${sensorKeyNormalized}_temperature&quot;] = payload&#10;                        } else {&#10;                            if (payload.toFloatOrNull() != null &amp;&amp; payload.toFloat() &lt; 100) {&#10;                                updated[&quot;${sensorKeyNormalized}_temperature&quot;] = &quot;$payload°C&quot;&#10;                            } else {&#10;                                updated[&quot;${sensorKeyNormalized}_humidity&quot;] = &quot;$payload%&quot;&#10;                            }&#10;                        }&#10;                    }&#10;                    sensorKeyNormalized.startsWith(&quot;ds18b20_&quot;) -&gt; {&#10;                        updated[&quot;${sensorKeyNormalized}_temperature&quot;] = payload&#10;                    }&#10;                }&#10;                updated[&quot;lastUpdated&quot;] = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date()) + &quot; (hace &quot; + formatTimeAgo(System.currentTimeMillis()) + &quot;)&quot;&#10;                _sensorData.value = updated&#10;                Log.d(TAG, &quot;Sensor $sensorKeyNormalized actualizado con valor simple: $payload&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Agrega esta función al final de la clase&#10;    fun toggleActuator(terrariumId: String, actuatorKey: String, newState: Boolean) {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Aquí deberías implementar la lógica para cambiar el estado del actuador en tu base de datos o enviar un comando MQTT.&#10;            // Por ahora, solo actualiza el estado localmente para evitar errores y permitir la interacción en la UI.&#10;            val updated = _actuatorStates.value.toMutableMap()&#10;            updated[actuatorKey] = newState&#10;            _actuatorStates.value = updated&#10;&#10;            // Si tienes lógica real para enviar el cambio al hardware, agrégala aquí.&#10;            // Por ejemplo:&#10;            // hiveMqttClient.publishActuatorCommand(terrariumId, actuatorKey, newState)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.waldoz_x.reptitrack.ui.screens.terrariumdetail&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.SavedStateHandle&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.waldoz_x.reptitrack.data.source.remote.HiveMqttClient&#10;import com.waldoz_x.reptitrack.domain.model.Terrarium&#10;import com.waldoz_x.reptitrack.domain.repository.TerrariumRepository&#10;import com.waldoz_x.reptitrack.navigation.Destinations&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Dispatchers // Importar Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext // Importar withContext&#10;import java.util.Date&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import kotlin.random.Random&#10;&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class TerrariumDetailViewModel @Inject constructor(&#10;    private val terrariumRepository: TerrariumRepository,&#10;    private val hiveMqttClient: HiveMqttClient,&#10;    savedStateHandle: SavedStateHandle&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;TerrariumDetailViewModel&quot;&#10;&#10;    private val _terrariumState = MutableStateFlow&lt;Terrarium?&gt;(null)&#10;    val terrariumState: StateFlow&lt;Terrarium?&gt; = _terrariumState.asStateFlow()&#10;&#10;    private val _sensorData = MutableStateFlow&lt;Map&lt;String, String&gt;&gt;(emptyMap())&#10;    val sensorData: StateFlow&lt;Map&lt;String, String&gt;&gt; = _sensorData.asStateFlow()&#10;&#10;    private val _actuatorStates = MutableStateFlow&lt;Map&lt;String, Boolean&gt;&gt;(emptyMap())&#10;    val actuatorStates: StateFlow&lt;Map&lt;String, Boolean&gt;&gt; = _actuatorStates.asStateFlow()&#10;&#10;    val isMqttConnected: StateFlow&lt;Boolean&gt; = hiveMqttClient.isConnected&#10;&#10;    private val terrariumId: String = savedStateHandle.get&lt;String&gt;(Destinations.TERRARIUM_ID_ARG)&#10;        ?: throw IllegalStateException(&quot;Terrarium ID no encontrado en los argumentos de navegación.&quot;)&#10;&#10;    // Usa el userId correcto para que coincida con los topics MQTT reales&#10;    private val userId: String = &quot;Ipzro9ETmRX9moHzQ0QNXv06SBy1&quot;&#10;&#10;    init {&#10;        Log.d(TAG, &quot;ViewModel inicializado para Terrario ID: $terrariumId&quot;)&#10;        startSimulatedSensorUpdates() // &lt;-- Siempre simular datos&#10;        loadTerrariumData()&#10;        observeMqttMessages()&#10;        observeMqttConnection()&#10;    }&#10;&#10;    // Simula y actualiza datos de sensores cada 2 segundos (excepto pzem)&#10;    private fun startSimulatedSensorUpdates() {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            while (true) {&#10;                // DHT: temperatura 22.0 - 24.3, humedad 55.0 - 62.0&#10;                fun tempDht() = String.format(&quot;%.2f°C&quot;, Random.nextDouble(22.0, 24.3))&#10;                fun humDht() = String.format(&quot;%.2f%%&quot;, Random.nextDouble(55.0, 62.0))&#10;                // DS18B20: temperatura 24.5 - 25.7&#10;                fun tempDsb() = String.format(&quot;%.2f°C&quot;, Random.nextDouble(24.5, 25.7))&#10;                val current = _sensorData.value.toMutableMap()&#10;                // DHT11&#10;                current[&quot;dht11_1_humidity&quot;] = humDht()&#10;                current[&quot;dht11_1_temperature&quot;] = tempDht()&#10;                // DHT22&#10;                current[&quot;dht22_1_humidity&quot;] = humDht()&#10;                current[&quot;dht22_1_temperature&quot;] = tempDht()&#10;                current[&quot;dht22_2_humidity&quot;] = humDht()&#10;                current[&quot;dht22_2_temperature&quot;] = tempDht()&#10;                current[&quot;dht22_3_humidity&quot;] = humDht()&#10;                current[&quot;dht22_3_temperature&quot;] = tempDht()&#10;                current[&quot;dht22_4_humidity&quot;] = humDht()&#10;                current[&quot;dht22_4_temperature&quot;] = tempDht()&#10;                // DS18B20&#10;                current[&quot;ds18b20_1_temperature&quot;] = tempDsb()&#10;                current[&quot;ds18b20_2_temperature&quot;] = tempDsb()&#10;                current[&quot;ds18b20_3_temperature&quot;] = tempDsb()&#10;                current[&quot;ds18b20_4_temperature&quot;] = tempDsb()&#10;                current[&quot;ds18b20_5_temperature&quot;] = tempDsb()&#10;                // Última actualización&#10;                current[&quot;lastUpdated&quot;] = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date()) + &quot; (Simulado)&quot;&#10;                // pzem_1_power NO se toca aquí, solo por MQTT real&#10;                _sensorData.value = current&#10;                kotlinx.coroutines.delay(2000)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadTerrariumData() {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            terrariumRepository.getTerrariumById(&#10;                userId = userId,&#10;                id = terrariumId&#10;            ).collect { terrarium -&gt;&#10;                _terrariumState.value = terrarium&#10;                terrarium?.let {&#10;                    _actuatorStates.value = mapOf(&#10;                        &quot;water_pump_active&quot; to it.waterPumpActive,&#10;                        &quot;fan1_active&quot; to it.fan1Active,&#10;                        &quot;fan2_active&quot; to it.fan2Active,&#10;                        &quot;light1_active&quot; to it.light1Active,&#10;                        &quot;light2_active&quot; to it.light2Active,&#10;                        &quot;light3_active&quot; to it.light3Active,&#10;                        &quot;heat_plate1_active&quot; to it.heatPlate1Active&#10;                    )&#10;&#10;                    val currentSensorData = mutableMapOf&lt;String, String&gt;()&#10;&#10;                    it.dht22_1_temperature?.let { temp -&gt; currentSensorData[&quot;dht22_1_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.dht22_1_humidity?.let { hum -&gt; currentSensorData[&quot;dht22_1_humidity&quot;] = &quot;${hum}%&quot; }&#10;                    it.dht22_2_temperature?.let { temp -&gt; currentSensorData[&quot;dht22_2_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.dht22_2_humidity?.let { hum -&gt; currentSensorData[&quot;dht22_2_humidity&quot;] = &quot;${hum}%&quot; }&#10;                    it.dht22_3_temperature?.let { temp -&gt; currentSensorData[&quot;dht22_3_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.dht22_3_humidity?.let { hum -&gt; currentSensorData[&quot;dht22_3_humidity&quot;] = &quot;${hum}%&quot; }&#10;                    it.dht22_4_temperature?.let { temp -&gt; currentSensorData[&quot;dht22_4_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.dht22_4_humidity?.let { hum -&gt; currentSensorData[&quot;dht22_4_humidity&quot;] = &quot;${hum}%&quot; }&#10;&#10;                    it.ds18b20_1_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_1_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.ds18b20_2_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_2_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.ds18b20_3_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_3_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.ds18b20_4_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_4_temperature&quot;] = &quot;${temp}°C&quot; }&#10;                    it.ds18b20_5_temperature?.let { temp -&gt; currentSensorData[&quot;ds18b20_5_temperature&quot;] = &quot;${temp}°C&quot; }&#10;&#10;                    it.hc_sr04_1_distance?.let { dist -&gt; currentSensorData[&quot;hc_sr04_1_distance&quot;] = &quot;${dist} cm&quot; }&#10;                    it.pzem_1_power?.let { power -&gt; currentSensorData[&quot;pzem_1_power&quot;] = &quot;${power} W&quot; }&#10;&#10;                    currentSensorData[&quot;lastUpdated&quot;] = it.lastUpdated.let { timestamp -&gt;&#10;                        if (timestamp != null &amp;&amp; timestamp &gt; 0) {&#10;                            val date = Date(timestamp)&#10;                            val sdf = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault())&#10;                            sdf.format(date) + &quot; (hace &quot; + formatTimeAgo(timestamp) + &quot;)&quot;&#10;                        } else {&#10;                            &quot;N/A&quot;&#10;                        }&#10;                    }&#10;&#10;                    _sensorData.value = currentSensorData&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun formatTimeAgo(timestamp: Long): String {&#10;        val now = System.currentTimeMillis()&#10;        val diff = now - timestamp&#10;&#10;        val seconds = diff / 1000&#10;        val minutes = seconds / 60&#10;        val hours = minutes / 60&#10;        val days = hours / 24&#10;&#10;        return when {&#10;            seconds &lt; 60 -&gt; &quot;$seconds s&quot;&#10;            minutes &lt; 60 -&gt; &quot;$minutes min&quot;&#10;            hours &lt; 24 -&gt; &quot;$hours h&quot;&#10;            else -&gt; &quot;$days d&quot;&#10;        }&#10;    }&#10;&#10;    private fun observeMqttMessages() {&#10;        viewModelScope.launch {&#10;            combine(hiveMqttClient.isConnected, hiveMqttClient.receivedMessages) { isConnected, messagePair -&gt;&#10;                if (isConnected &amp;&amp; messagePair != null) {&#10;                    messagePair&#10;                } else {&#10;                    null&#10;                }&#10;            }.collect { messagePair -&gt;&#10;                messagePair?.let { (topic, payload) -&gt;&#10;                    Log.d(TAG, &quot;Mensaje MQTT recibido en ViewModel: $topic -&gt; $payload&quot;)&#10;                    // El procesamiento del mensaje puede ser ligero, pero si se vuelve complejo,&#10;                    // considera moverlo a un Dispatchers.Default o Dispatchers.IO&#10;                    processMqttMessage(topic, payload)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun observeMqttConnection() {&#10;        viewModelScope.launch {&#10;            hiveMqttClient.isConnected.collect { isConnected -&gt;&#10;                if (isConnected) {&#10;                    Log.d(TAG, &quot;Conexión MQTT establecida, suscribiendo a tópicos del usuario: $userId&quot;)&#10;                    withContext(Dispatchers.IO) {&#10;                        // Suscríbete al topic real de tus sensores&#10;                        hiveMqttClient.subscribeToTopic(&quot;reptritrack/$userId/esp02/sensores/#&quot;)&#10;                    }&#10;                } else {&#10;                    Log.d(TAG, &quot;Conexión MQTT perdida para usuario: $userId&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun processMqttMessage(topic: String, payload: String) {&#10;        // Solo para el sensor de potencia, procesa únicamente la potencia&#10;        if (topic == &quot;reptritrack/D85QPSadZhd8pXC0dpBwEUGD5gR2/esp01/sensores/pzem004&quot;) {&#10;            try {&#10;                val map = payload.trim()&#10;                    .removePrefix(&quot;{&quot;).removeSuffix(&quot;}&quot;)&#10;                    .split(&quot;,&quot;)&#10;                    .map { it.split(&quot;:&quot;) }&#10;                    .associate { it[0].replace(&quot;\&quot;&quot;, &quot;&quot;).trim() to it[1].replace(&quot;\&quot;&quot;, &quot;&quot;).trim() }&#10;&#10;                val updated = _sensorData.value.toMutableMap()&#10;                map[&quot;potencia&quot;]?.let { potencia -&gt;&#10;                    updated[&quot;pzem_1_power&quot;] = &quot;$potencia W&quot;&#10;                }&#10;                updated[&quot;lastUpdated&quot;] = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date()) + &quot; (hace &quot; + formatTimeAgo(System.currentTimeMillis()) + &quot;)&quot;&#10;                _sensorData.value = updated&#10;                Log.d(TAG, &quot;Sensor pzem004 actualizado solo con potencia: $payload&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error al parsear JSON de pzem004: $payload&quot;, e)&#10;            }&#10;            return&#10;        }&#10;&#10;        // Para todos los demás sensores, deja el comportamiento tal cual&#10;        val parts = topic.split(&quot;/&quot;)&#10;        if (parts.size &gt;= 5 &amp;&amp; parts[0] == &quot;reptritrack&quot; &amp;&amp; parts[2] == &quot;esp02&quot; &amp;&amp; parts[3] == &quot;sensores&quot;) {&#10;            val sensorKeyRaw = parts[4]&#10;            val sensorKeyNormalized = sensorKeyRaw&#10;                .replace(Regex(&quot;_(0*)([1-9][0-9]*)$&quot;), &quot;_$2&quot;)&#10;&#10;            if (payload.trim().startsWith(&quot;{&quot;) &amp;&amp; payload.trim().endsWith(&quot;}&quot;)) {&#10;                try {&#10;                    val map = payload.trim()&#10;                        .removePrefix(&quot;{&quot;).removeSuffix(&quot;}&quot;)&#10;                        .split(&quot;,&quot;)&#10;                        .map { it.split(&quot;:&quot;) }&#10;                        .associate { it[0].replace(&quot;\&quot;&quot;, &quot;&quot;).trim() to it[1].replace(&quot;\&quot;&quot;, &quot;&quot;).trim() }&#10;&#10;                    val updated = _sensorData.value.toMutableMap()&#10;                    map.forEach { (k, v) -&gt;&#10;                        val key = when (k.lowercase()) {&#10;                            &quot;temperature&quot;, &quot;temperatura&quot; -&gt; &quot;${sensorKeyNormalized}_temperature&quot;&#10;                            &quot;humidity&quot;, &quot;humedad&quot; -&gt; &quot;${sensorKeyNormalized}_humidity&quot;&#10;                            &quot;distance&quot;, &quot;distancia&quot; -&gt; &quot;${sensorKeyNormalized}_distance&quot;&#10;                            &quot;power&quot;, &quot;potencia&quot; -&gt; &quot;${sensorKeyNormalized}_power&quot;&#10;                            else -&gt; &quot;${sensorKeyNormalized}_$k&quot;&#10;                        }&#10;                        val value = when (k.lowercase()) {&#10;                            &quot;temperature&quot;, &quot;temperatura&quot; -&gt; &quot;$v°C&quot;&#10;                            &quot;humidity&quot;, &quot;humedad&quot; -&gt; &quot;$v%&quot;&#10;                            &quot;distance&quot;, &quot;distancia&quot; -&gt; &quot;$v cm&quot;&#10;                            &quot;power&quot;, &quot;potencia&quot; -&gt; &quot;$v W&quot;&#10;                            else -&gt; v&#10;                        }&#10;                        updated[key] = value&#10;                    }&#10;                    updated[&quot;lastUpdated&quot;] = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date()) + &quot; (hace &quot; + formatTimeAgo(System.currentTimeMillis()) + &quot;)&quot;&#10;                    _sensorData.value = updated&#10;                    Log.d(TAG, &quot;Sensor $sensorKeyNormalized actualizado con JSON: $payload&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error al parsear JSON de sensor: $payload&quot;, e)&#10;                }&#10;            } else {&#10;                val updated = _sensorData.value.toMutableMap()&#10;                when {&#10;                    sensorKeyNormalized.startsWith(&quot;dht22_&quot;) -&gt; {&#10;                        if (payload.contains(&quot;%&quot;)) {&#10;                            updated[&quot;${sensorKeyNormalized}_humidity&quot;] = payload&#10;                        } else if (payload.contains(&quot;°C&quot;)) {&#10;                            updated[&quot;${sensorKeyNormalized}_temperature&quot;] = payload&#10;                        } else {&#10;                            if (payload.toFloatOrNull() != null &amp;&amp; payload.toFloat() &lt; 100) {&#10;                                updated[&quot;${sensorKeyNormalized}_temperature&quot;] = &quot;$payload°C&quot;&#10;                            } else {&#10;                                updated[&quot;${sensorKeyNormalized}_humidity&quot;] = &quot;$payload%&quot;&#10;                            }&#10;                        }&#10;                    }&#10;                    sensorKeyNormalized.startsWith(&quot;ds18b20_&quot;) -&gt; {&#10;                        updated[&quot;${sensorKeyNormalized}_temperature&quot;] = payload&#10;                    }&#10;                }&#10;                updated[&quot;lastUpdated&quot;] = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date()) + &quot; (hace &quot; + formatTimeAgo(System.currentTimeMillis()) + &quot;)&quot;&#10;                _sensorData.value = updated&#10;                Log.d(TAG, &quot;Sensor $sensorKeyNormalized actualizado con valor simple: $payload&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Agrega esta función al final de la clase&#10;    fun toggleActuator(terrariumId: String, actuatorKey: String, newState: Boolean) {&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            // Aquí deberías implementar la lógica para cambiar el estado del actuador en tu base de datos o enviar un comando MQTT.&#10;            // Por ahora, solo actualiza el estado localmente para evitar errores y permitir la interacción en la UI.&#10;            val updated = _actuatorStates.value.toMutableMap()&#10;            updated[actuatorKey] = newState&#10;            _actuatorStates.value = updated&#10;&#10;            // Si tienes lógica real para enviar el cambio al hardware, agrégala aquí.&#10;            // Por ejemplo:&#10;            // hiveMqttClient.publishActuatorCommand(terrariumId, actuatorKey, newState)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>